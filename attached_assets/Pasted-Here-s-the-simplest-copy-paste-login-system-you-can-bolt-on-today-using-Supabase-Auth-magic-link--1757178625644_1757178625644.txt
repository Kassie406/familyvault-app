Here’s the simplest, copy-paste login system you can bolt on today using Supabase Auth (magic link). It gives you email sign-in, logged-in state, and a family_id so Shared Lists stay private.

1) Create Supabase & add env vars

Make a project at supabase.com

In Replit (or your env), add:

VITE_SUPABASE_URL=...your project url...
VITE_SUPABASE_ANON_KEY=...your anon key...


Install the client:

npm i @supabase/supabase-js


/src/lib/supabase.js

import { createClient } from "@supabase/supabase-js";
export const supabase = createClient(
  import.meta.env.VITE_SUPABASE_URL,
  import.meta.env.VITE_SUPABASE_ANON_KEY
);

2) Tiny login UI (magic link)

/src/auth/SignIn.jsx

import { useState } from "react";
import { supabase } from "../lib/supabase";

export default function SignIn() {
  const [email, setEmail] = useState("");
  const [sent, setSent] = useState(false);

  async function sendLink(e) {
    e.preventDefault();
    const { error } = await supabase.auth.signInWithOtp({ email }); // passwordless
    if (error) alert(error.message);
    else setSent(true);
  }

  return sent ? (
    <div className="text-white">Check your email to finish sign-in.</div>
  ) : (
    <form onSubmit={sendLink} className="flex gap-2">
      <input
        className="px-3 py-2 rounded bg-black/40 text-white border border-white/10"
        placeholder="you@email.com"
        value={email} onChange={(e)=>setEmail(e.target.value)}
      />
      <button className="px-3 py-2 rounded bg-[#c5a000] text-black font-semibold">Send Link</button>
    </form>
  );
}


/src/auth/RequireAuth.jsx

import { useEffect, useState } from "react";
import { supabase } from "../lib/supabase";
import SignIn from "./SignIn";

export default function RequireAuth({ children }) {
  const [ready, setReady] = useState(false);
  const [user, setUser] = useState(null);

  useEffect(() => {
    supabase.auth.getUser().then(({ data }) => {
      setUser(data?.user ?? null);
      setReady(true);
    });
    const { data: sub } = supabase.auth.onAuthStateChange((_e, sess) => {
      setUser(sess?.user ?? null);
    });
    return () => sub?.subscription?.unsubscribe();
  }, []);

  if (!ready) return null;
  return user ? children : (
    <div className="p-6 rounded-2xl bg-black/90 text-white border border-white/10">
      <h2 className="text-xl font-semibold mb-2">Sign in to continue</h2>
      <SignIn />
    </div>
  );
}


Wrap your dashboard page:

import RequireAuth from "./auth/RequireAuth";
import Dashboard from "./Dashboard";

export default function App() {
  return (
    <RequireAuth>
      <Dashboard />
    </RequireAuth>
  );
}

3) Give users a family space (one-time setup)

Create two tables + rules (paste in Supabase → SQL):

-- Profiles
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  family_id text not null,
  name text,
  created_at timestamptz default now()
);
alter table public.profiles enable row level security;
create policy "read own profile" on public.profiles for select using (id = auth.uid());
create policy "update own profile" on public.profiles for update using (id = auth.uid());

-- List items (your Shared Lists)
create table if not exists public.list_items (
  id uuid primary key default gen_random_uuid(),
  family_id text not null,
  user_id uuid references auth.users(id),
  text text not null,
  assignee text,
  due_date date,
  done boolean default false,
  created_at timestamptz default now()
);
alter table public.list_items enable row level security;
create policy "family read"   on public.list_items for select using (exists (select 1 from profiles p where p.id=auth.uid() and p.family_id=list_items.family_id));
create policy "family insert" on public.list_items for insert with check (exists (select 1 from profiles p where p.id=auth.uid() and p.family_id=list_items.family_id));
create policy "family update" on public.list_items for update using (exists (select 1 from profiles p where p.id=auth.uid() and p.family_id=list_items.family_id));
create policy "family delete" on public.list_items for delete using (exists (select 1 from profiles p where p.id=auth.uid() and p.family_id=list_items.family_id));

How do users get a family_id?

Easiest: after a new user signs in the first time, run this one-time “join family” call (you can hardcode one family for now or use an invite code later):

import { supabase } from "../lib/supabase";

// Call once after sign-in
export async function ensureProfile({ family_id = "fam_gds" }) {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error("Not signed in");
  await supabase.from("profiles").upsert({
    id: user.id,
    family_id,
    name: user.email
  });
}


Call it right after login or when the app mounts:

useEffect(() => {
  supabase.auth.getUser().then(async ({ data }) => {
    if (data?.user) {
      await ensureProfile({ family_id: "fam_gds" }); // <- all your family members share this
    }
  });
}, []);

4) Hook Shared Lists to Supabase (not local memory)

Use the data helpers from earlier (load/add/toggle/delete). Minimal version:

import { supabase } from "../lib/supabase";

async function getFamilyId() {
  const { data: { user } } = await supabase.auth.getUser();
  const { data } = await supabase.from("profiles").select("family_id").eq("id", user.id).single();
  return data.family_id;
}

export async function loadItems() {
  const fam = await getFamilyId();
  const { data } = await supabase.from("list_items").select("*").eq("family_id", fam).order("created_at", { ascending: false });
  return data ?? [];
}
export async function addItem({ text, assignee, due }) {
  const fam = await getFamilyId();
  const { data } = await supabase.from("list_items").insert({ family_id: fam, text, assignee: assignee || "Unassigned", due_date: due || null }).select().single();
  return data;
}
export async function toggleItem(id) {
  const { data: cur } = await supabase.from("list_items").select("done").eq("id", id).single();
  const { data } = await supabase.from("list_items").update({ done: !cur.done }).eq("id", id).select().single();
  return data;
}
export async function deleteItem(id) {
  await supabase.from("list_items").delete().eq("id", id);
  return id;
}


Then, in your SharedLists component:

useEffect(() => { if (open) loadItems().then(setItems); }, [open]);

<SharedListsModal
  items={items}
  onClose={() => setOpen(false)}
  onAdd={async (draft) => setItems(prev => [await addItem(draft), ...prev])}
  onToggle={async (id) => setItems(prev => prev.map(i => i.id===id ? await toggleItem(id) : i))}
  onDelete={async (id) => { await deleteItem(id); setItems(prev => prev.filter(i=>i.id!==id)); }}
/>

5) (Optional) Real-time updates in 5 lines

So when one person checks off an item, everyone sees it instantly:

useEffect(() => {
  let sub;
  (async () => {
    const fam = await getFamilyId();
    sub = supabase
      .channel("lists")
      .on("postgres_changes", { event: "*", schema: "public", table: "list_items", filter: `family_id=eq.${fam}` },
        () => loadItems().then(setItems)
      )
      .subscribe();
  })();
  return () => sub && supabase.removeChannel(sub);
}, []);

That’s it

You now have a login system (magic link).

A family space via family_id.

Private, persistent Shared Lists using Supabase.

Optional real-time sync.