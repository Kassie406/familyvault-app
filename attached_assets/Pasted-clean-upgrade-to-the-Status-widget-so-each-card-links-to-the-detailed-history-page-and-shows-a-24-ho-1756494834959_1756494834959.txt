clean upgrade to the Status widget so each card links to the detailed history page and shows a 24-hour average latency badge. I’ll add a tiny server “summary” endpoint, then the widget + a route link.

1) Server summary endpoint (last result + 24h avg latency)

File: src/routes/admin/status.js
(Add these two routes below your existing ones.)

// Get last check per component + 24h avg latency
router.get('/summary', requireAdmin, async (_req, res) => {
  const { rows: last } = await db.query(`
    SELECT DISTINCT ON (component)
      component, ok, latency_ms, ts
    FROM status_checks
    ORDER BY component, ts DESC
  `);

  const { rows: avg } = await db.query(`
    SELECT component, AVG(latency_ms)::int AS avg_latency_ms
    FROM status_checks
    WHERE ts > now() - interval '24 hours'
    GROUP BY component
  `);

  const avgMap = Object.fromEntries(avg.map(r => [r.component, r.avg_latency_ms]));
  const components = last.map(r => ({
    component: r.component,
    ok: r.ok,
    latency_ms: r.latency_ms,
    avg_latency_ms: avgMap[r.component] ?? null,
    ts: r.ts
  }));

  res.json({ components });
});


(You already have /admin/status/public and the history routes; this adds a richer summary feed.)

2) Console routing: link target for details

If you used the StatusPage.tsx I gave earlier, ensure it’s mounted at /console/status (or similar). For example:

// src/console/ConsoleRouter.tsx
import { Routes, Route } from 'react-router-dom';
import HomePage from './pages/HomePage';
import StatusPage from './pages/StatusPage';
// …other imports

export default function ConsoleRouter() {
  return (
    <Routes>
      <Route path="/console" element={<HomePage />} />
      <Route path="/console/status" element={<StatusPage />} />
      {/* …others */}
    </Routes>
  );
}

3) Upgraded Status Widget (click-through + avg latency badge)

Replace your widget with this version:

File: src/console/components/StatusWidget.tsx

import React, { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';

type Comp = {
  component: string;
  ok: boolean;
  latency_ms?: number;
  avg_latency_ms?: number | null;
  ts?: string;
};

const GOLD = '#E0B530';

function Pill({ ok }: { ok: boolean }) {
  return (
    <span
      style={{
        display:'inline-flex', alignItems:'center', gap:6, padding:'4px 8px',
        borderRadius:999, fontSize:12, fontWeight:600,
        color: ok ? '#0b0c0f' : '#fff', background: ok ? '#22c55e' : '#ef4444'
      }}
    >
      <span style={{ width:8, height:8, borderRadius:'50%', background: ok ? '#065f46' : '#7f1d1d' }} />
      {ok ? 'OK' : 'FAIL'}
    </span>
  );
}

function LatencyBadge({ now, avg }: { now?: number; avg?: number | null }) {
  if (avg == null && now == null) return null;
  const txt = [
    now != null ? `now ${now}ms` : null,
    avg != null ? `24h ${avg}ms` : null
  ].filter(Boolean).join(' · ');
  return (
    <span
      title="Current vs 24h average latency"
      style={{
        marginLeft:8, fontSize:12, padding:'2px 8px', borderRadius:999,
        background:'#12161a', border:'1px solid #2b3036', color:'#dfe5ee'
      }}
    >
      {txt}
    </span>
  );
}

export default function StatusWidget() {
  const [items, setItems] = useState<Comp[]>([]);
  const [loading, setLoading] = useState(true);
  const [last, setLast] = useState<Date | null>(null);
  const [err, setErr] = useState<string | null>(null);
  const navigate = useNavigate();

  async function load() {
    setErr(null);
    try {
      const r = await fetch('/admin/status/summary', { credentials:'include' });
      if (!r.ok) throw new Error('Failed to fetch status summary');
      const j = await r.json();
      // Stable order
      const order = ['db','smtp','webhooks','auth','stripe'];
      const sorted = [
        ...order.map(k => j.components.find((c:Comp) => c.component === k)).filter(Boolean),
        ...j.components.filter((c:Comp) => !order.includes(c.component))
      ] as Comp[];
      setItems(sorted);
      setLast(new Date());
    } catch (e: any) {
      setErr(e.message || 'Error');
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    load();
    const id = setInterval(load, 30_000);
    return () => clearInterval(id);
  }, []);

  return (
    <div className="card" style={{ borderColor:'#23282d' }}>
      <div style={{ display:'flex', alignItems:'center', marginBottom:8 }}>
        <h2 style={{ margin:0, fontSize:18 }}>System Status</h2>
        <div style={{ marginLeft:'auto', display:'flex', gap:8 }}>
          <button className="btn" onClick={() => navigate('/console/status')} style={{ borderColor:GOLD }}>
            View details
          </button>
          {last && <span style={{ fontSize:12, opacity:.7 }}>Updated {last.toLocaleTimeString()}</span>}
          <button className="btn" onClick={load} disabled={loading} style={{ borderColor:GOLD }}>
            {loading ? 'Refreshing…' : 'Refresh'}
          </button>
        </div>
      </div>

      {err && <div style={{ marginBottom:8, color:'#ef4444' }}>{err}</div>}

      <div style={{ display:'grid', gridTemplateColumns:'repeat(auto-fit, minmax(200px,1fr))', gap:12 }}>
        {items.map((c) => (
          <button
            key={c.component}
            onClick={() => navigate('/console/status')}
            className="card"
            style={{
              textAlign:'left', cursor:'pointer',
              background:'#0f1316',
              border:`1px solid ${c.ok ? '#1d2a21' : '#2a1b1b'}`,
              boxShadow: c.ok
                ? '0 0 0 1px rgba(34,197,94,.08) inset'
                : '0 0 0 1px rgba(239,68,68,.08) inset'
            }}
          >
            <div style={{ display:'flex', alignItems:'center', gap:8 }}>
              <div style={{
                width:28, height:28, borderRadius:8, background:'#0c1013',
                border:'1px solid #2b3036', display:'grid', placeItems:'center'
              }}>
                <div style={{ width:10, height:10, borderRadius:'50%', background: c.ok ? '#22c55e' : '#ef4444' }} />
              </div>
              <div style={{ display:'grid' }}>
                <strong style={{ textTransform:'uppercase', fontSize:12, letterSpacing:.5 }}>{c.component}</strong>
                <span style={{ opacity:.8, fontSize:12 }}>Health</span>
              </div>
              <div style={{ marginLeft:'auto', display:'flex', alignItems:'center' }}>
                <Pill ok={c.ok} />
                <LatencyBadge now={c.latency_ms} avg={c.avg_latency_ms ?? undefined} />
              </div>
            </div>
          </button>
        ))}
        {items.length === 0 && !loading && !err && (
          <div style={{ opacity:.7 }}>No components reported yet.</div>
        )}
      </div>
    </div>
  );
}

4) Optional: small polish on the history page

On your StatusPage.tsx, add a tiny header link back:

<div className="page-header">
  <h1>System Status</h1>
  <a className="btn" href="/console">← Back to dashboard</a>
</div>

5) “Tell Replit what to do” (paste this)

Prompt for Replit

Add a new admin route GET /admin/status/summary that returns, for each component, the latest result (ok, latency_ms, ts) and the 24-hour average latency (avg_latency_ms).

Replace src/console/components/StatusWidget.tsx with the upgraded version that fetches /admin/status/summary, renders OK/FAIL cards with a latency badge (“now Xms · 24h Yms”), refreshes every 30s, and makes each card clickable to /console/status. Keep the dark theme with gold accent #E0B530.

Ensure the console router has a route at /console/status using the existing StatusPage.tsx.

If you want, I can next add toasts when any component flips from OK→FAIL, using a lastSeenState in localStorage, or wire Slack alerts when checks fail consecutively.

You said:
ok go ahead
ChatGPT said:
Thought for 8s

Awesome — let’s wire real-time toasts in the console when a component flips state, and Slack alerts when checks fail (and when they recover). Everything plugs into the Status module you already have.

A) Frontend: toast alerts on OK↔FAIL flips

1) Toast system (reusable)
src/console/components/ToastHost.tsx

import React, { createContext, useCallback, useContext, useMemo, useState } from 'react';

type Toast = { id: string; kind: 'error'|'success'|'info'; title: string; body?: string };
type Ctx = { push: (t: Omit<Toast,'id'>) => void };

const ToastCtx = createContext<Ctx | null>(null);
export function useToasts() {
  const ctx = useContext(ToastCtx);
  if (!ctx) throw new Error('ToastHost missing');
  return ctx;
}

export default function ToastHost({ children }: { children: React.ReactNode }) {
  const [items, setItems] = useState<Toast[]>([]);

  const push = useCallback((t: Omit<Toast,'id'>) => {
    const id = crypto.randomUUID();
    const toast: Toast = { id, ...t };
    setItems(prev => [toast, ...prev]);
    setTimeout(() => setItems(prev => prev.filter(x => x.id !== id)), 6000);
  }, []);

  const ctx = useMemo<Ctx>(() => ({ push }), [push]);

  return (
    <ToastCtx.Provider value={ctx}>
      {children}
      <div style={{
        position:'fixed', right:16, bottom:16, display:'grid', gap:10, zIndex:9998, width:'min(360px, 92vw)'
      }}>
        {items.map(t => (
          <div key={t.id} style={{
            background:'#0f1316',
            border:'1px solid ' + (t.kind==='error' ? '#7f1d1d' : t.kind==='success' ? '#1d2a21' : '#2b3036'),
            borderRadius:12, padding:'10px 12px', boxShadow:'0 10px 30px rgba(0,0,0,.35)', color:'#e8eaf0'
          }}>
            <div style={{ display:'flex', alignItems:'center', gap:8 }}>
              <span style={{
                width:10, height:10, borderRadius:'50%',
                background: t.kind==='error' ? '#ef4444' : t.kind==='success' ? '#22c55e' : '#E0B530'
              }} />
              <strong>{t.title}</strong>
            </div>
            {t.body && <div style={{ opacity:.9, marginTop:6, fontSize:13 }}>{t.body}</div>}
          </div>
        ))}
      </div>
    </ToastCtx.Provider>
  );
}


2) Status watcher (polls summary, compares to last state)
src/console/components/StatusWatcher.tsx

import React, { useEffect } from 'react';
import { useToasts } from './ToastHost';

type Comp = { component: string; ok: boolean; latency_ms?: number };
const KEY = 'fcs-status-last';

export default function StatusWatcher() {
  const { push } = useToasts();

  async function check() {
    const r = await fetch('/admin/status/summary', { credentials:'include' });
    if (!r.ok) return;
    const j = await r.json() as { components: Comp[] };

    const prev = JSON.parse(localStorage.getItem(KEY) || '{}') as Record<string, boolean>;
    const now: Record<string, boolean> = {};
    j.components.forEach(c => {
      now[c.component] = c.ok;
      if (prev[c.component] === undefined) return; // first run, no toast
      if (prev[c.component] !== c.ok) {
        if (c.ok) {
          push({
            kind:'success',
            title:`${c.component.toUpperCase()} recovered`,
            body:`Component is back to OK.`
          });
        } else {
          push({
            kind:'error',
            title:`${c.component.toUpperCase()} failing`,
            body:`Recent check indicates a failure.`
          });
        }
      }
    });
    localStorage.setItem(KEY, JSON.stringify(now));
  }

  useEffect(() => {
    // prime state without toasts
    (async () => {
      try {
        const r = await fetch('/admin/status/summary', { credentials:'include' });
        if (!r.ok) return;
        const j = await r.json();
        const init: Record<string, boolean> = {};
        (j.components || []).forEach((c: Comp) => init[c.component] = c.ok);
        localStorage.setItem(KEY, JSON.stringify(init));
      } catch {}
    })();

    const id = setInterval(check, 30_000);
    return () => clearInterval(id);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return null; // no UI, just toasts
}


3) Wrap your console once
src/console/AppShell.tsx (or your root layout)

import React from 'react';
import ToastHost from './components/ToastHost';
import StatusWatcher from './components/StatusWatcher';
import ImpersonationBanner from './components/ImpersonationBanner';
import './styles/impersonation.css';

export default function AppShell({ children }: { children: React.ReactNode }) {
  return (
    <ToastHost>
      <ImpersonationBanner />
      <StatusWatcher />
      <div style={{ paddingTop: 44 }}>{children}</div>
    </ToastHost>
  );
}


That’s it — your console will pop a red FAIL toast when a component flips to failing, and a green recovered toast when it comes back.

B) Backend: Slack alerts on consecutive failures & on recovery

1) Slack notifier
src/notify/slack.js

import fetch from 'node-fetch';

export async function slackNotify(text, blocks) {
  const url = process.env.SLACK_WEBHOOK_URL;
  if (!url) return;
  await fetch(url, {
    method:'POST',
    headers:{ 'Content-Type':'application/json' },
    body: JSON.stringify(blocks ? { text, blocks } : { text })
  }).catch(() => {});
}


ENV

SLACK_WEBHOOK_URL=https://hooks.slack.com/services/xxxxx/yyyyy/zzzzz


2) Failure streak + recovery detection
Update your status routes (same file as /admin/status/run and /admin/status/summary).

Add helpers near top of src/routes/admin/status.js:

async function getLastTwoFor(component, db) {
  const { rows } = await db.query(
    `SELECT ok, ts FROM status_checks WHERE component=$1 ORDER BY ts DESC LIMIT 2`, [component]
  );
  return rows;
}

async function consecutiveFailCount(component, db, upto = 5) {
  const { rows } = await db.query(
    `SELECT ok FROM status_checks WHERE component=$1 ORDER BY ts DESC LIMIT $2`,
    [component, upto]
  );
  let c = 0;
  for (const r of rows) {
    if (r.ok === false) c += 1; else break;
  }
  return c;
}


Then modify your run route so that after each saveCheck you evaluate flips/streaks and send Slack:

import { slackNotify } from '../../notify/slack.js';

// inside router.post('/run', ...)
for (const fn of [checkDB, checkSMTP, checkStripe]) {
  const r = await fn();
  checks.push(r);
  await saveCheck(r);

  // Flip detection (last->current)
  const lastTwo = await getLastTwoFor(r.component, db);
  if (lastTwo.length === 2) {
    const [current, previous] = lastTwo; // ordered DESC by ts
    if (previous.ok === true && current.ok === false) {
      await slackNotify(`❌ ${r.component.toUpperCase()} FAILED`,
        [
          { type:'section', text:{ type:'mrkdwn', text:`*❌ ${r.component.toUpperCase()} FAILED*` } },
          { type:'context', elements:[{ type:'mrkdwn', text:`Status flip from OK → FAIL` }] }
        ]
      );
    }
    if (previous.ok === false && current.ok === true) {
      await slackNotify(`✅ ${r.component.toUpperCase()} RECOVERED`,
        [
          { type:'section', text:{ type:'mrkdwn', text:`*✅ ${r.component.toUpperCase()} RECOVERED*` } },
          { type:'context', elements:[{ type:'mrkdwn', text:`Back to OK` }] }
        ]
      );
    }
  }

  // Streak detection (e.g., 3 consecutive fails)
  if (r.ok === false) {
    const streak = await consecutiveFailCount(r.component, db, 5);
    if (streak === 3) {
      await slackNotify(`🚨 ${r.component.toUpperCase()} failing 3x in a row`,
        [
          { type:'section', text:{ type:'mrkdwn', text:`*🚨 ${r.component.toUpperCase()} failing 3x in a row*` } },
          { type:'context', elements:[{ type:'mrkdwn', text:`Please investigate.` }] }
        ]
      );
    }
  }
}


This will post Slack messages when:

a component flips OK → FAIL (incident),

flips FAIL → OK (recovery),

hits 3 consecutive fails (escalation).

If you prefer a Slack bot token + chat.postMessage, we can switch easily; webhooks are the quickest.

C) “Tell Replit what to do” (paste this)

Prompt for Replit

Add a toast system: create src/console/components/ToastHost.tsx and wrap the console shell with it. Add src/console/components/StatusWatcher.tsx that polls /admin/status/summary every 30s, compares to the last stored state in localStorage, and shows toasts when any component flips OK→FAIL (red) or FAIL→OK (green).

Add Slack alerts: create src/notify/slack.js (incoming webhook) and update the /admin/status/run route to send a Slack message when a component flips OK→FAIL or FAIL→OK, and when it reaches 3 consecutive failures. Use SLACK_WEBHOOK_URL from env.

Ensure the Status widget/summary endpoint already exist (from previous steps). Keep styles consistent with the dark theme + gold accent. RBAC remains required for admin routes.

Want me to add rate-limit to Slack alerts (so a noisy component doesn’t spam), or a maintenance mode toggle that suppresses alerts and shows a banner?

You said:
ok
ChatGPT said:

Perfect 👍 here’s your next step:

Drop the ToastHost and StatusWatcher components into your console shell so your admin sees live toast alerts when any component flips.

Add the Slack notifier and streak detection into /admin/status/run so incidents and recoveries push straight into your Slack channel.

That gives you:
✅ Real-time UI toasts for admins
✅ Slack alerts for failures, recoveries, and streaks
✅ Tamper-evident audit trail already in your DB

👉 Question for you before I continue: do you want me to add alert suppression (so a flaky service doesn’t spam 20 Slack messages in a row), or should we keep it simple first and add that later?

You said:
yes
ChatGPT said:

Great — I’ll add alert suppression + an optional maintenance mode so Slack doesn’t get spammed.

Below are drop-in pieces (Node/Express + Postgres). They extend the Status module you already have.

1) DB: track alert state & maintenance
-- 013_status_alert_state.sql
CREATE TABLE status_alert_state (
  component TEXT PRIMARY KEY,        -- 'db','smtp','stripe',...
  last_state BOOLEAN,                -- last ok/fail we alerted on
  last_alert_at TIMESTAMPTZ,
  cooldown_until TIMESTAMPTZ,        -- suppress until this time (per component)
  daily_sent INT NOT NULL DEFAULT 0, -- counter for today
  counter_date DATE NOT NULL DEFAULT CURRENT_DATE
);

-- single maintenance switch for status alerts
CREATE TABLE status_maintenance (
  id BOOLEAN PRIMARY KEY DEFAULT TRUE, -- always one row
  enabled BOOLEAN NOT NULL DEFAULT FALSE,
  reason TEXT,
  until TIMESTAMPTZ
);
INSERT INTO status_maintenance (id, enabled) VALUES (TRUE, FALSE) ON CONFLICT DO NOTHING;

2) Server helpers (cooldown + daily cap + maintenance)

File: src/status/alerts.js

import db from '../db.js';

const COOLDOWN_MINUTES = 20;           // per-component cooldown after a Slack alert
const DAILY_CAP = 8;                    // per-component per-day max Slack messages

export async function isMaintenanceOn() {
  const { rows } = await db.query(`SELECT enabled, until FROM status_maintenance WHERE id=TRUE`);
  if (!rows.length) return false;
  const { enabled, until } = rows[0];
  if (!enabled) return false;
  if (until && new Date(until) < new Date()) {
    await db.query(`UPDATE status_maintenance SET enabled=FALSE, until=NULL WHERE id=TRUE`);
    return false;
  }
  return true;
}

export async function canAlert(component) {
  // rotate counter if date changed
  await db.query(`
    INSERT INTO status_alert_state (component) VALUES ($1)
    ON CONFLICT (component) DO NOTHING
  `, [component]);

  await db.query(`
    UPDATE status_alert_state
       SET daily_sent = CASE WHEN counter_date <> CURRENT_DATE THEN 0 ELSE daily_sent END,
           counter_date = CASE WHEN counter_date <> CURRENT_DATE THEN CURRENT_DATE ELSE counter_date END
     WHERE component=$1
  `, [component]);

  const { rows } = await db.query(
    `SELECT cooldown_until, daily_sent FROM status_alert_state WHERE component=$1`,
    [component]
  );
  if (!rows.length) return { allowed: true };
  const { cooldown_until, daily_sent } = rows[0];

  if (cooldown_until && new Date(cooldown_until) > new Date()) return { allowed: false, reason: 'cooldown' };
  if (daily_sent >= DAILY_CAP) return { allowed: false, reason: 'daily_cap' };
  return { allowed: true };
}

export async function markAlert(component) {
  await db.query(`
    UPDATE status_alert_state
       SET daily_sent = daily_sent + 1,
           last_alert_at = now(),
           cooldown_until = now() + interval '${COOLDOWN_MINUTES} minutes'
     WHERE component=$1
  `, [component]);
}

export async function recordState(component, ok) {
  await db.query(`
    INSERT INTO status_alert_state (component, last_state)
    VALUES ($1,$2)
    ON CONFLICT (component) DO UPDATE SET last_state=EXCLUDED.last_state
  `, [component, ok]);
}

3) Admin routes: toggle maintenance & view suppression state

File: src/routes/admin/status-maintenance.js

import express from 'express';
import db from '../../db.js';
import { requireAdmin } from '../../mw/requireAdmin.js';

const router = express.Router();

router.get('/maintenance', requireAdmin, async (_req,res) => {
  const { rows } = await db.query(`SELECT enabled, reason, until FROM status_maintenance WHERE id=TRUE`);
  res.json(rows[0] || { enabled:false });
});

router.post('/maintenance', requireAdmin, async (req,res) => {
  const { enabled, reason, minutes } = req.body;
  const until = enabled && minutes ? `now() + interval '${Number(minutes)} minutes'` : 'NULL';
  const { rows } = await db.query(`
    UPDATE status_maintenance
       SET enabled=$1, reason=$2, until=${until}
     WHERE id=TRUE
     RETURNING enabled, reason, until
  `, [!!enabled, reason || null]);
  res.json(rows[0]);
});

router.get('/alerts/state', requireAdmin, async (_req,res) => {
  const { rows } = await db.query(`
    SELECT component, last_state, last_alert_at, cooldown_until, daily_sent, counter_date
      FROM status_alert_state ORDER BY component
  `);
  res.json({ items: rows });
});

export default router;


Mount

// app.js
import statusMaintenance from './routes/admin/status-maintenance.js';
app.use('/admin/status', statusMaintenance);

4) Wire suppression into Slack alert logic

In your existing router.post('/run', ...) (Status checks), change the part where you call slackNotify to respect maintenance, cooldown, and daily cap:

import { slackNotify } from '../../notify/slack.js';
import { isMaintenanceOn, canAlert, markAlert, recordState } from '../../status/alerts.js';

// ... inside the for-loop after saveCheck(r)
await recordState(r.component, r.ok);

const maintenance = await isMaintenanceOn();
if (!maintenance) {
  // Flip detection
  const lastTwo = await getLastTwoFor(r.component, db);
  const flipToFail = lastTwo.length === 2 && lastTwo[1].ok === true && lastTwo[0].ok === false;
  const flipToOk   = lastTwo.length === 2 && lastTwo[1].ok === false && lastTwo[0].ok === true;

  if (flipToFail || flipToOk) {
    const gate = await canAlert(r.component);
    if (gate.allowed) {
      await slackNotify(flipToFail
        ? `❌ ${r.component.toUpperCase()} FAILED`
        : `✅ ${r.component.toUpperCase()} RECOVERED`);
      await markAlert(r.component);
    }
  }

  // Consecutive fail escalation (3x)
  if (r.ok === false) {
    const streak = await consecutiveFailCount(r.component, db, 5);
    if (streak === 3) {
      const gate = await canAlert(r.component);
      if (gate.allowed) {
        await slackNotify(`🚨 ${r.component.toUpperCase()} failing 3x consecutively — please investigate.`);
        await markAlert(r.component);
      }
    }
  }
}
// else: maintenance enabled → suppress all Slack alerts

5) Tiny Console UI: Maintenance toggle on Status page

Add this to the top of your StatusPage.tsx:

import React, { useEffect, useState } from 'react';

function MaintenanceToggle() {
  const [st, setSt] = useState<{enabled:boolean;reason?:string;until?:string}>({enabled:false});
  const [minutes, setMinutes] = useState(60);
  const [reason, setReason] = useState('');

  async function load() {
    const r = await fetch('/admin/status/maintenance', { credentials:'include' });
    const j = await r.json(); setSt(j);
  }
  useEffect(()=>{ load(); }, []);

  async function enable() {
    const r = await fetch('/admin/status/maintenance', {
      method:'POST', credentials:'include',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ enabled:true, reason, minutes })
    });
    const j = await r.json(); setSt(j);
  }
  async function disable() {
    const r = await fetch('/admin/status/maintenance', {
      method:'POST', credentials:'include',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ enabled:false })
    });
    const j = await r.json(); setSt(j);
  }

  return (
    <div className="card" style={{ marginBottom: 12 }}>
      <div style={{ display:'flex', alignItems:'center', gap:12 }}>
        <strong>Maintenance mode</strong>
        <span style={{ fontSize:12, opacity:.8 }}>
          {st.enabled ? `ON ${st.until ? `(until ${new Date(st.until).toLocaleTimeString()})` : ''}` : 'OFF'}
        </span>
        <div style={{ marginLeft:'auto', display:'flex', gap:8 }}>
          {!st.enabled ? (
            <>
              <input className="input" placeholder="Reason (optional)" value={reason} onChange={e=>setReason(e.target.value)} />
              <input className="input" type="number" min={5} max={240} value={minutes} onChange={e=>setMinutes(Number(e.target.value))} style={{ width:100 }} />
              <button className="btn btn-primary" onClick={enable}>Enable</button>
            </>
          ) : (
            <button className="btn" onClick={disable}>Disable</button>
          )}
        </div>
      </div>
    </div>
  );
}


Then render <MaintenanceToggle /> above your checks table.

6) “Tell Replit what to do” (paste this)

Prompt for Replit

Create a Postgres table status_alert_state to track per-component alert cooldown, daily counts, and last state; and a status_maintenance table with a single row toggle (enabled, reason, optional until).

Add src/status/alerts.js with helpers isMaintenanceOn(), canAlert(), markAlert(), recordState(). Use a 20-minute cooldown and a per-day cap of 8 alerts per component.

Add admin routes under /admin/status:

GET /maintenance (returns current state)

POST /maintenance (enable/disable; accepts minutes and reason)

GET /alerts/state (inspect suppression state)

Modify /admin/status/run so Slack alerts are suppressed during maintenance and whenever canAlert() denies (cooldown/daily cap). On each send, call markAlert(). Continue to post flip and 3x-fail alerts otherwise.

Update the console StatusPage.tsx to include a MaintenanceToggle card to enable/disable maintenance (with duration and reason). Keep the existing dark theme and gold accent (#E0B530). RBAC unchanged.

That gives you:

✅ Noisy components won’t spam Slack (cooldown + daily cap)

✅ “Maintenance mode” one-click mute with auto-expiry

✅ Simple admin UI to toggle and inspect