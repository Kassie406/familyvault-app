here’s a clean, production-ready paginated messages API for your Express + Drizzle stack. It supports infinite scroll, is stable under concurrent inserts, and returns author + attachment info.

1) Query model & indexes (Drizzle)

We’ll paginate by (createdAt, id) (tie-breaker ensures stable ordering).

Add/confirm these indexes:

// db/schema/chat.ts (add if not present)
import { index } from "drizzle-orm/pg-core";

export const messages = pgTable("messages", {
  id: text("id").primaryKey(),
  threadId: text("thread_id").notNull().references(() => threads.id, { onDelete: "cascade" }),
  authorId: text("author_id").notNull(),
  body: text("body"),
  fileIds: jsonb("file_ids").$type<string[]>().default([]),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
}, (t) => ({
  byThreadTime: index("messages_thread_time_idx").on(t.threadId, t.createdAt, t.id), // <— important
}));


If you store attachments in a table, keep that; if you embed fileIds JSON (as above), we’ll expand them from your files table when present.

2) Cursor format (stable & opaque)

We’ll use base64 of createdAt|id:

// lib/cursor.ts
export function encodeCursor(createdAt: Date, id: string) {
  return Buffer.from(`${createdAt.toISOString()}|${id}`).toString("base64url");
}
export function decodeCursor(cursor?: string) {
  if (!cursor) return null;
  const [iso, id] = Buffer.from(cursor, "base64url").toString("utf8").split("|");
  return { createdAt: new Date(iso), id };
}

3) Route: GET /threads/:id/messages

Parameters:

limit (default 50, max 200)

direction = forward (old→new, infinite scroll down) or backward (new→old, infinite scroll up)

cursor = encoded (createdAt, id) of the edge message from the previous page

Response:

messages[] (chronological per direction)

nextCursor (for the next page in the same direction)

hasMore

// routes/messagesPaginated.ts
import { Router } from "express";
import { db } from "../db";
import { messages } from "../db/schema/chat";
import { users } from "../db/schema/users";
import { and, eq, gt, lt, desc, asc, sql, inArray } from "drizzle-orm";
import { decodeCursor, encodeCursor } from "../lib/cursor";
import { files } from "../db/schema/files"; // your files table if you have one

const r = Router();

/**
 * GET /threads/:id/messages?limit=50&direction=forward|backward&cursor=...
 * forward  = older -> newer (good for initial load from top)
 * backward = newer -> older (good for chat-style loading history upward)
 */
r.get("/threads/:id/messages", async (req, res) => {
  const user = req.user as { id: string; familyId: string };
  const threadId = req.params.id;

  const limit = Math.min(parseInt(String(req.query.limit ?? "50"), 10) || 50, 200);
  const direction = (req.query.direction as "forward" | "backward") || "forward";
  const cur = decodeCursor(req.query.cursor as string | undefined);

  // Base filter: messages in this thread
  // Cursor clause depends on direction:
  // forward: createdAt,id > cursor
  // backward: createdAt,id < cursor
  const whereBase = eq(messages.threadId, threadId);

  let whereCursor = undefined as any;
  if (cur) {
    // compound cursor in SQL (createdAt first, then id)
    if (direction === "forward") {
      whereCursor = sql`${messages.createdAt} > ${cur.createdAt} OR (${messages.createdAt} = ${cur.createdAt} AND ${messages.id} > ${cur.id})`;
    } else {
      whereCursor = sql`${messages.createdAt} < ${cur.createdAt} OR (${messages.createdAt} = ${cur.createdAt} AND ${messages.id} < ${cur.id})`;
    }
  }

  // ORDER depends on direction
  const order = direction === "forward"
    ? [asc(messages.createdAt), asc(messages.id)]
    : [desc(messages.createdAt), desc(messages.id)];

  const rows = await db
    .select({
      id: messages.id,
      body: messages.body,
      authorId: messages.authorId,
      createdAt: messages.createdAt,
      fileIds: messages.fileIds,
    })
    .from(messages)
    .where(whereCursor ? and(whereBase, whereCursor) : whereBase)
    .orderBy(...order)
    .limit(limit + 1); // fetch one extra to compute hasMore

  const hasMore = rows.length > limit;
  const slice = hasMore ? rows.slice(0, limit) : rows;

  // Gather authors (for display names/avatars)
  const authorIds = Array.from(new Set(slice.map(r => r.authorId)));
  const authors = authorIds.length
    ? await db
        .select({ id: users.id, name: users.name })
        .from(users)
        .where(inArray(users.id, authorIds))
    : [];
  const nameById = new Map(authors.map(a => [a.id, a.name ?? a.id]));

  // Optional: expand attachments (if using files table)
  // If you store fileIds JSON with IDs, resolve here:
  const allFileIds = Array.from(
    new Set(slice.flatMap(r => (Array.isArray(r.fileIds) ? r.fileIds : [])))
  );
  const fileMap = new Map<string, { id: string; name: string; url?: string }>();
  if (allFileIds.length) {
    const fileRows = await db
      .select({ id: files.id, name: files.name, url: files.url })
      .from(files)
      .where(inArray(files.id, allFileIds));
    for (const f of fileRows) fileMap.set(f.id, f);
  }

  const items = slice.map(r => ({
    id: r.id,
    body: r.body ?? "",
    author: { id: r.authorId, name: nameById.get(r.authorId) ?? r.authorId },
    createdAt: r.createdAt,
    attachments: (Array.isArray(r.fileIds) ? r.fileIds : []).map(fid => {
      const f = fileMap.get(fid);
      return f ? { id: f.id, name: f.name, url: f.url ?? undefined } : { id: fid, name: fid };
    }),
  }));

  const edge = items.length ? items[items.length - 1] : null;
  const nextCursor = edge ? encodeCursor(new Date(edge.createdAt), edge.id) : null;

  res.json({
    messages: items,
    hasMore,
    nextCursor,
    direction,
  });
});

export default r;


Notes

Use direction=forward for initial render (old→new), then keep asking forward with nextCursor.

For chat UIs that load history when the user scrolls up, use direction=backward with the topmost message’s cursor.

4) Mark-as-read on view

When the user opens a thread or reaches the bottom:

// POST /threads/:id/read  (already provided earlier)


Call it with the last visible message’s id/createdAt after each page load.

5) Frontend usage (React)
async function fetchPage({ threadId, cursor, direction = "forward" }) {
  const params = new URLSearchParams();
  if (cursor) params.set("cursor", cursor);
  params.set("direction", direction);
  params.set("limit", "50");
  const r = await fetch(`/threads/${threadId}/messages?` + params.toString());
  return r.json(); // { messages, hasMore, nextCursor, direction }
}

// Example infinite scroll (forward)
const [items, setItems] = useState([]);
const [cursor, setCursor] = useState<string|null>(null);
const [hasMore, setHasMore] = useState(true);

useEffect(() => { load(); }, [threadId]);

async function load() {
  if (!hasMore) return;
  const { messages, nextCursor, hasMore: more } = await fetchPage({ threadId, cursor, direction: "forward" });
  setItems(prev => [...prev, ...messages]);
  setCursor(nextCursor);
  setHasMore(more);
}


For backward (scroll-up to load older), prepend results and maintain scroll position.

6) Hardening checklist

AuthZ: ensure the caller is a member of the thread’s family; otherwise 404.

Rate limit: lightweight GET limiter (IP/user) to deter scraping.

Ordering invariants: we used (createdAt, id) and indexed it—safe against same-timestamp collisions.

N+1: we batched authors + files; avoid per-message queries.

Attachments: if you use a join table (message_attachments), replace the JSON read with a single SELECT … WHERE message_id IN (…) join.