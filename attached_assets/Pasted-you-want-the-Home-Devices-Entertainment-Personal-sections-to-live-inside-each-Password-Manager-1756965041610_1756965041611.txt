you want the Home / Devices / Entertainment / Personal sections to live inside each Password Manager card (Angel‚Äôs, Kassandra‚Äôs), instead of being global. Here‚Äôs a clean way to do it with minimal churn to your current components.

Plan (what changes + why)

Data shape

Ensure each credential knows which manager it belongs to and what section it‚Äôs in.

type ManagerId = "angel" | "kassandra";

type SectionKey = "home" | "devices" | "entertainment" | "personal";

interface Credential {
  id: string;
  title: string;
  owner: ManagerId;         // <-- which manager vault
  section: SectionKey;      // <-- which section inside the vault
  type: "device" | "network" | "access" | "account" | "subscription";
  // ...rest (mask, icons, metadata)
}

interface Manager {
  id: ManagerId;
  name: string;             // ‚ÄúAngel‚Äôs Password Manager‚Äù
  prepopulatedCount: number;
}


UI structure

Keep your two Password Manager cards at the top.

Make each card expandable. When expanded, it displays that manager‚Äôs four sections (Home, Devices & Electronics, Entertainment & Subscriptions, Personal Accounts).

Each section shows its own credential cards and a small ‚Äú+ Add‚Äù for that section (pre-fills section + manager in the add form).

Optional: add ‚ÄúExpand all / Collapse all‚Äù button near filters.

Filtering

Your existing ‚ÄúAll Owners / All Types‚Äù filters still work; they simply filter the credentials before grouping them inside the expanded manager card.

Backend / DB

If you already store credentials per owner, add a section column/field (enum). If you don‚Äôt store manager/owner, add owner too.

For the create/edit forms, include hidden defaults when launching ‚Äú+ Add‚Äù from a section (owner & section preselected).

Drop-in React (Tailwind + your existing shells)

Below is a compact implementation sketch using your Shell, ManagerCard, and CredentialCard styles. It adds an expandable manager with internal sections. You can paste this into your passwords page and wire your real data where indicated.

import React, { useMemo, useState } from "react";
import { ChevronDown, ChevronRight, Plus, Home, Tv, Smartphone, LockKeyhole } from "lucide-react";
import { cn } from "@/lib/utils";

// --- Types (align to your real types) -----------------
type ManagerId = "angel" | "kassandra";
type SectionKey = "home" | "devices" | "entertainment" | "personal";

type Credential = {
  id: string;
  title: string;
  owner: ManagerId;
  section: SectionKey;
  icon?: React.ReactNode;
  meta?: { ownerLabel?: string; typeLabel?: string };
};

type Manager = { id: ManagerId; name: string; prepopulatedCount: number };

// --- Section metadata ---------------------------------
const SECTION_META: Record<
  SectionKey,
  { label: string; sub: string; icon: React.ReactNode }
> = {
  home: { label: "Home", sub: "WiFi, codes, home access", icon: <Home className="h-4 w-4" /> },
  devices: { label: "Devices & Electronics", sub: "Phones, laptops, smart devices", icon: <Smartphone className="h-4 w-4" /> },
  entertainment: { label: "Entertainment & Subscriptions", sub: "Streaming, music, media", icon: <Tv className="h-4 w-4" /> },
  personal: { label: "Personal Accounts", sub: "Banking, email, and personal services", icon: <LockKeyhole className="h-4 w-4" /> },
};

// --- Visual shells (reuse your existing ones) ----------
function CardShell({ children, className = "" }: React.PropsWithChildren<{ className?: string }>) {
  return (
    <div
      className={cn(
        "rounded-2xl border border-[#232530] bg-gradient-to-b from-[#161616] to-[#0F0F0F]",
        "shadow-[0_10px_28px_rgba(0,0,0,0.45)] hover:border-[#D4AF37]/70",
        className
      )}
    >
      {children}
    </div>
  );
}

function ManagerHeader({
  name,
  count,
  expanded,
  onToggle,
}: {
  name: string;
  count: number;
  expanded: boolean;
  onToggle: () => void;
}) {
  return (
    <button
      onClick={onToggle}
      className="w-full flex items-center justify-between px-5 py-4"
    >
      <div className="flex items-center gap-3">
        <div className="h-10 w-10 grid place-items-center rounded-xl bg-[#D4AF37]/15 text-[#D4AF37] border border-[#232530]">
          <span className="font-medium">üîê</span>
        </div>
        <div className="text-left">
          <div className="text-white font-medium">{name}</div>
          <div className="text-xs text-neutral-400">+ {count} items pre-populated</div>
        </div>
      </div>
      {expanded ? (
        <ChevronDown className="h-5 w-5 text-neutral-400" />
      ) : (
        <ChevronRight className="h-5 w-5 text-neutral-400" />
      )}
    </button>
  );
}

function SectionHeader({
  icon,
  title,
  sub,
  onAdd,
}: {
  icon: React.ReactNode;
  title: string;
  sub: string;
  onAdd: () => void;
}) {
  return (
    <div className="flex items-start justify-between mb-3">
      <div className="flex items-center gap-2">
        <div className="h-8 w-8 grid place-items-center rounded-lg bg-[#111214] border border-[#232530] text-neutral-300">
          {icon}
        </div>
        <div>
          <div className="text-[15px] text-white font-medium">{title}</div>
          <div className="text-xs text-neutral-500">{sub}</div>
        </div>
      </div>
      <button
        onClick={onAdd}
        className="flex items-center gap-2 text-sm text-[#D4AF37] hover:underline underline-offset-4"
      >
        <Plus className="h-4 w-4" /> Add
      </button>
    </div>
  );
}

// --- Reuse your existing credential card look ----------
function CredentialCardMini({ cred }: { cred: Credential }) {
  return (
    <CardShell className="p-4">
      <div className="flex items-start gap-3">
        <div className="h-9 w-9 rounded-lg grid place-items-center bg-[#111214] border border-[#232530] text-neutral-300">
          {cred.icon ?? "üîë"}
        </div>
        <div className="min-w-0 flex-1">
          <div className="text-sm text-white font-medium truncate">{cred.title}</div>
          <div className="text-xs text-neutral-500 mt-0.5">
            {cred.meta?.ownerLabel && (
              <>Owner: <span className="text-neutral-300">{cred.meta.ownerLabel}</span></>
            )}
            {cred.meta?.typeLabel && (
              <>
                {" "}<span className="text-neutral-600">‚Ä¢</span>{" "}
                <span className="text-neutral-400">{cred.meta.typeLabel}</span>
              </>
            )}
          </div>
          <div className="mt-2 flex items-center gap-3 text-xs">
            <button className="text-[#D4AF37] hover:underline underline-offset-4">Reveal</button>
            <span className="text-neutral-600">‚Ä¢</span>
            <button className="text-neutral-300 hover:text-white">Copy</button>
          </div>
        </div>
        <button className="h-8 w-8 grid place-items-center rounded-lg text-neutral-400 hover:text-white">‚ãØ</button>
      </div>
    </CardShell>
  );
}

// --- Manager with internal sections --------------------
function ManagerWithSections({
  manager,
  credentials,
  onAdd,
  defaultOpen = false,
}: {
  manager: Manager;
  credentials: Credential[];
  onAdd: (owner: ManagerId, section: SectionKey) => void;
  defaultOpen?: boolean;
}) {
  const [open, setOpen] = useState(defaultOpen);

  // Group this manager's credentials by section
  const grouped = useMemo(() => {
    const by: Record<SectionKey, Credential[]> = {
      home: [], devices: [], entertainment: [], personal: []
    };
    for (const c of credentials) {
      if (c.owner === manager.id) by[c.section].push(c);
    }
    return by;
  }, [credentials, manager.id]);

  return (
    <CardShell>
      <ManagerHeader
        name={manager.name}
        count={manager.prepopulatedCount}
        expanded={open}
        onToggle={() => setOpen(!open)}
      />
      {open && (
        <div className="px-5 pb-5 space-y-8">
          {(Object.keys(SECTION_META) as SectionKey[]).map((key) => {
            const meta = SECTION_META[key];
            const items = grouped[key];
            return (
              <div key={key}>
                <SectionHeader
                  icon={meta.icon}
                  title={meta.label}
                  sub={meta.sub}
                  onAdd={() => onAdd(manager.id, key)}
                />
                {items.length === 0 ? (
                  <div className="text-xs text-neutral-500 pl-1">No items yet.</div>
                ) : (
                  <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                    {items.map((cred) => (
                      <CredentialCardMini key={cred.id} cred={cred} />
                    ))}
                  </div>
                )}
              </div>
            );
          })}
        </div>
      )}
    </CardShell>
  );
}

// --- Page usage ----------------------------------------
export default function PasswordsManagersView({
  managers,
  allCredentials,
}: {
  managers: Manager[];
  allCredentials: Credential[];
}) {
  const handleAdd = (owner: ManagerId, section: SectionKey) => {
    // Open your ‚ÄúAdd credential‚Äù modal with preselected owner+section
    // openAddModal({ owner, section });
    console.log("Add credential for", owner, "section", section);
  };

  return (
    <div className="space-y-6">
      {/* Optional: filters above here */}

      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {managers.map((m) => (
          <ManagerWithSections
            key={m.id}
            manager={m}
            credentials={allCredentials}
            onAdd={handleAdd}
            defaultOpen={true} // or false if you prefer collapsed by default
          />
        ))}
      </div>
    </div>
  );
}

What you get

Each Password Manager card is now the container for its own sections.

The red-circled rows (Home, Devices & Electronics, Entertainment & Subscriptions, Personal Accounts) now live inside Angel‚Äôs and Kassandra‚Äôs cards respectively.

‚Äú+ Add‚Äù inside a section launches your form pre-filled with { owner: "angel", section: "devices" }, etc.

Filtering keeps working because we filter allCredentials first, then pass down to each Manager card.

Quick migration checklist

DB/Schema

Add section enum (home | devices | entertainment | personal).

Ensure owner/managerId is present.

Backfill existing items with sensible sections.

API

Allow create/update endpoints to accept { owner, section }.

Update list endpoint to return owner & section.

UI

Replace global sections with ManagerWithSections.

In ‚ÄúAdd credential‚Äù modal, read owner & section from state if provided.

If you want, I can wire this directly to your existing components and data fetches (just share the props shape you‚Äôre using for credentials right now).