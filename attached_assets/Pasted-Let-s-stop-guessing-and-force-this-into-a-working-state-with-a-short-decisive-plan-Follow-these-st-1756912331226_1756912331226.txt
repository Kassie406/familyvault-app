Let’s stop guessing and force this into a working state with a short, decisive plan. Follow these steps exactly. If any step fails, tell me the error text and I’ll pinpoint the fix.

A. Make sure the deployed API is actually reachable
1) Deployment settings (Replit → Deployments → Settings)

Type: Web server

Build command: vite build && esbuild server/index.ts --platform=node --outdir=dist --format=cjs

Start command: NODE_ENV=production node dist/index.js

Port: your server must do app.listen(process.env.PORT || 5000, '0.0.0.0')

2) Production env vars (Replit → Deployments → Secrets)
NODE_ENV=production
APP_URL=https://portal.familycirclesecure.com
DATABASE_URL=postgres://<YOUR_NEON_CONNECTION>
DEV_BYPASS_AUTH=true     # <— TEMPORARY to eliminate auth as a blocker

3) Post-deploy command
npm run db:push

4) Redeploy

Deploy again so these values are used.

5) Health check

Visit:

https://portal.familycirclesecure.com/api/healthz


You must get JSON like {"ok":true}.
If you see HTML/404 → the Start command isn’t running the API. Fix Step A.1 and redeploy.

B. Add hard logging + a test endpoint (copy-paste)

Open your server/index.ts and make sure these are present near the top (and before any SPA/Vite fallback):

app.get('/api/healthz', (req, res) => res.json({ ok: true, t: Date.now() }));

app.post('/api/test-post', (req, res) => {
  console.log('[test-post] hit', new Date().toISOString());
  res.json({ ok: true });
});

// VERY IMPORTANT: routes for /api/* MUST be defined BEFORE any SPA fallback.
// If you mount a static build or Vite dev middleware, they must come AFTER your API routes.


In the regenerate handler, add one log line:

app.post('/api/credentials/:id/shares/regenerate', async (req, res) => {
  console.log('[regen] id=', req.params.id, 'ip=', req.ip, 'ts=', Date.now());
  // ... existing logic
});


Redeploy. Then:

Hit POST /api/test-post from your browser console:

fetch('/api/test-post', {method:'POST'}).then(r=>r.json()).then(console.log)


You should see {ok:true} and a [test-post] hit line in Deploy → Logs.
If not, the API isn’t running (go back to A.1).

C. Prove DB + route actually work (no UI)

In the portal tab, open DevTools → Console and run:

(async () => {
  const credId = 'c-garage'; // replace with the id you’re testing
  const r = await fetch(`/api/credentials/${credId}/shares/regenerate`, {
    method: 'POST',
    headers: {'content-type':'application/json'},
    body: JSON.stringify({ expiry:'7d', requireLogin:false }) // requireLogin false while DEV_BYPASS_AUTH=true
  });
  const text = await r.text();
  console.log('status:', r.status, 'ct:', r.headers.get('content-type'), 'body:', text.slice(0,200));
})();


Interpretation:

status 200 + JSON body → backend is good; any UI “Timeout” is front-end only.

status 500 → open Deployments → Logs; paste the error line here.

HTML body or 404 → the SPA is intercepting /api/*. Ensure Step B note: API routes must be registered before any SPA middleware/fallback and redeploy.

Hangs → Start command isn’t running, or DB is blocking; check logs.

D. Flip auth back on (once C works)

Change DEV_BYPASS_AUTH=false in deployment secrets.

Redeploy.

Re-run the console snippet. If you now get 401, it means the cookie didn’t reach the API:

Cookies must be Secure; SameSite=Lax (same origin).

Replit proxy must forward Cookie header (it does for Web Server).

Make sure you’re logged in on the same domain (portal.familycirclesecure.com).

E. Fix the UI showing generic “Timeout”

Replace your fetch wrapper with this (it will show the real reason if something breaks):

async function regenerateShareLink(credentialId: string, opts: {expiry:'24h'|'7d'|'30d'|'never', requireLogin:boolean}) {
  const ctrl = new AbortController();
  const to = setTimeout(() => ctrl.abort(), 15000);
  try {
    const res = await fetch(`/api/credentials/${credentialId}/shares/regenerate`, {
      method: 'POST',
      headers: {'content-type':'application/json'},
      body: JSON.stringify(opts),
      signal: ctrl.signal,
    });
    const ct = res.headers.get('content-type') || '';
    const bodyText = await res.text();

    if (!res.ok) throw new Error(`HTTP ${res.status} – ${bodyText.slice(0,200)}`);
    if (!ct.includes('application/json')) throw new Error('Non-JSON response (SPA intercepted /api).');

    return JSON.parse(bodyText); // {url, token}
  } finally {
    clearTimeout(to);
  }
}


Now you’ll see exactly whether it’s 401, 404, 500, or HTML.

Why this works (and why it’s “solid”)

DEV_BYPASS_AUTH=true temporarily removes auth as a variable so we can verify routing + DB quickly.

Test endpoints + logs make the backend status undeniable (you’ll see the hits in Replit logs).

/api before SPA guarantees the API isn’t swallowed by the front-end.

db:push post-deploy removes schema drift as a cause of hangs.

UI error surfacing eliminates the “Timeout” black box.