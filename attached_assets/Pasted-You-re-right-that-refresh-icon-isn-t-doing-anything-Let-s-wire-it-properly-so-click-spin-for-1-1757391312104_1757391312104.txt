You’re right—that refresh icon isn’t doing anything. Let’s wire it properly so:

click = spin for ~1s

fetches fresh data (no cache)

updates the list + count

disables itself while running

never double-fires

Below are two drop-in ways. Use A (with SWR) or B (vanilla React). Both match your dark UI and the existing “Family Activity” pattern.

A) SWR version (cleanest)
1) Hook
// lib/hooks/useFamilyUpdates.ts
import useSWR from "swr";

const fetcher = (url: string) => fetch(url, { cache: "no-store" }).then(r => r.json());

export function useFamilyUpdates(userId: string) {
  const { data, error, mutate, isLoading, isValidating } = useSWR(
    `/api/family/updates?user=${encodeURIComponent(userId)}`,
    fetcher,
    { revalidateOnFocus: false, dedupingInterval: 0 }
  );

  // ensure spinner shows at least 1s so the user sees it
  const refresh = async () => {
    const minSpin = new Promise(res => setTimeout(res, 1000));
    await Promise.all([mutate(), minSpin]);
  };

  return {
    items: data?.items ?? [],
    count: data?.count ?? 0,
    error,
    isLoading,
    isRefreshing: isValidating, // <- use this to spin
    refresh,
  };
}


Make sure your API route disables caching too:

// app/api/family/updates/route.ts
export const dynamic = "force-dynamic";
// or: res.headers.set("Cache-Control","no-store");

2) Reusable refresh button
// components/RefreshButton.tsx
"use client";
import { RefreshCw } from "lucide-react";

export function RefreshButton({
  onClick,
  spinning,
  label = "Refresh",
}: {
  onClick: () => void | Promise<void>;
  spinning: boolean;
  label?: string;
}) {
  return (
    <button
      type="button"
      onClick={onClick}
      disabled={spinning}
      aria-live="polite"
      className="rounded-full px-2 py-2 text-zinc-300 bg-transparent
                 ring-2 ring-[#c5a000] ring-offset-2 ring-offset-[#0b0b0e]
                 disabled:opacity-100 disabled:cursor-wait"
      title={label}
    >
      <RefreshCw className={`h-4 w-4 ${spinning ? "animate-spin" : ""}`} />
    </button>
  );
}

3) Family Updates card (wire it)
// components/cards/FamilyUpdatesCard.tsx
"use client";
import { RefreshButton } from "@/components/RefreshButton";
import { useFamilyUpdates } from "@/lib/hooks/useFamilyUpdates";

export default function FamilyUpdatesCard({ userId }: { userId: string }) {
  const { items, count, isRefreshing, refresh, error } = useFamilyUpdates(userId);

  return (
    <div className="rounded-2xl bg-zinc-900 p-4 h-auto">
      <div className="flex items-center justify-between mb-2">
        <div>
          <div className="text-sm text-zinc-300">Family Updates</div>
          <div className="text-xs text-zinc-500">Important notifications</div>
        </div>
        <RefreshButton onClick={refresh} spinning={isRefreshing} />
      </div>

      {error && (
        <div className="text-sm text-red-400">Couldn’t refresh. Please try again.</div>
      )}

      <ul className="space-y-2">
        {items.map((it: any) => (
          <li key={it.id} className="rounded-xl border border-zinc-800 p-3">
            <div className="text-sm text-zinc-200">{it.title}</div>
            <div className="text-xs text-zinc-500">{it.subtitle}</div>
          </li>
        ))}
      </ul>

      {/* optional count chip */}
      <div className="mt-3 text-xs text-zinc-500">{count} updates</div>
    </div>
  );
}

B) Vanilla React (no SWR)
// components/cards/FamilyUpdatesCard.tsx
"use client";
import { useEffect, useState } from "react";
import { RefreshCw } from "lucide-react";

type UpdateItem = { id: string; title: string; subtitle?: string };

export default function FamilyUpdatesCard({ userId }: { userId: string }) {
  const [items, setItems] = useState<UpdateItem[]>([]);
  const [count, setCount] = useState(0);
  const [spinning, setSpinning] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const load = async () => {
    setError(null);
    const res = await fetch(`/api/family/updates?user=${encodeURIComponent(userId)}`, {
      cache: "no-store",
      next: { revalidate: 0 },
    });
    if (!res.ok) throw new Error("fetch failed");
    const data = await res.json();
    setItems(data.items ?? []);
    setCount(data.count ?? 0);
  };

  useEffect(() => { load().catch(() => setError("Failed to load")); }, []);

  const refresh = async () => {
    if (spinning) return;
    setSpinning(true);
    try {
      const minSpin = new Promise(res => setTimeout(res, 1000));
      await Promise.all([load(), minSpin]);
    } catch {
      setError("Failed to refresh");
    } finally {
      setSpinning(false);
    }
  };

  return (
    <div className="rounded-2xl bg-zinc-900 p-4 h-auto">
      <div className="flex items-center justify-between mb-2">
        <div className="text-sm text-zinc-300">Family Updates</div>
        <button
          onClick={refresh}
          disabled={spinning}
          className="rounded-full px-2 py-2 text-zinc-300 bg-transparent
                     ring-2 ring-[#c5a000] ring-offset-2 ring-offset-[#0b0b0e]
                     disabled:opacity-100 disabled:cursor-wait"
          title="Refresh"
        >
          <RefreshCw className={`h-4 w-4 ${spinning ? "animate-spin" : ""}`} />
        </button>
      </div>

      {error && <div className="text-xs text-red-400 mb-2">{error}</div>}

      <ul className="space-y-2">
        {items.map(it => (
          <li key={it.id} className="rounded-xl border border-zinc-800 p-3">
            <div className="text-sm text-zinc-200">{it.title}</div>
            <div className="text-xs text-zinc-500">{it.subtitle}</div>
          </li>
        ))}
      </ul>

      <div className="mt-3 text-xs text-zinc-500">{count} updates</div>
    </div>
  );
}

If it still doesn’t spin…

Most common blockers:

Icon not bound to state – make sure the class toggles with spinning ? "animate-spin" : "".

Button covered – check no invisible overlay blocks clicks (pointer-events:none on overlay or z-10 on header).

Memoization – if the card is wrapped in memo, confirm spinning is a prop/state inside, not a stale prop.

Caching – Next fetches may cache by default; use cache:'no-store' (and/or dynamic="force-dynamic" on route).

Multiple handlers – ensure the refresh button’s onClick calls only refresh, not a parent onClick that stops propagation.

Quick test without API

Temporarily stub your route to see the spinner:

// app/api/family/updates/route.ts
export async function GET() {
  await new Promise(r => setTimeout(r, 500)); // simulate latency
  return Response.json({
    count: 3,
    items: [
      { id: "1", title: "Update Family Passwords", subtitle: "Due: Today" },
      { id: "2", title: "Car Insurance Renewal Due", subtitle: "Due: In 4 days" },
      { id: "3", title: "Mom’s Birthday Coming Up", subtitle: "Due: In 2 days" },
    ],
  }, { headers: { "Cache-Control": "no-store" } });
}


—

Plug one of the implementations in and your refresh icon will spin and actually re-load the data. If you want me to diff your current FamilyUpdates component, paste it and I’ll return the exact lines to replace.