// API Integration for Enhanced Upload Center
// File: utils/uploadApiIntegration.js

// API Configuration
const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || '/api';
const UPLOAD_ENDPOINT = `${API_BASE_URL}/upload`;
const ANALYZE_ENDPOINT = `${API_BASE_URL}/analyze-document`;

/**
 * Upload file with progress tracking
 * @param {File} file - The file to upload
 * @param {Function} onProgress - Progress callback function
 * @returns {Promise} Upload response
 */
export const uploadFileWithProgress = (file, onProgress) => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const formData = new FormData();
    
    // Add file to form data
    formData.append('file', file);
    formData.append('timestamp', Date.now().toString());
    formData.append('source', 'enhanced-upload-center');
    
    // Track upload progress
    xhr.upload.addEventListener('progress', (event) => {
      if (event.lengthComputable) {
        const progress = Math.round((event.loaded / event.total) * 100);
        onProgress(progress);
      }
    });
    
    // Handle successful upload
    xhr.addEventListener('load', () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        try {
          const response = JSON.parse(xhr.responseText);
          resolve(response);
        } catch (error) {
          reject(new Error('Invalid response format'));
        }
      } else {
        reject(new Error(`Upload failed with status: ${xhr.status}`));
      }
    });
    
    // Handle upload errors
    xhr.addEventListener('error', () => {
      reject(new Error('Network error during upload'));
    });
    
    // Handle upload timeout
    xhr.addEventListener('timeout', () => {
      reject(new Error('Upload timeout'));
    });
    
    // Configure and send request
    xhr.timeout = 60000; // 60 second timeout
    xhr.open('POST', UPLOAD_ENDPOINT);
    xhr.send(formData);
  });
};

/**
 * Analyze document using existing AWS Textract integration
 * @param {string} fileId - The uploaded file ID
 * @param {File} file - Original file object for metadata
 * @returns {Promise} Analysis results
 */
export const analyzeDocumentWithAI = async (fileId, file) => {
  try {
    const response = await fetch(ANALYZE_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        fileId: fileId,
        fileName: file.name,
        fileType: file.type,
        fileSize: file.size,
        analysisType: 'comprehensive', // Use comprehensive analysis
        extractionOptions: {
          extractText: true,
          extractTables: true,
          extractForms: true,
          detectDocumentType: true,
          identifyPersonalInfo: true
        }
      })
    });
    
    if (!response.ok) {
      throw new Error(`Analysis failed with status: ${response.status}`);
    }
    
    const result = await response.json();
    
    // Transform AWS Textract response to our UI format
    return transformAnalysisResult(result, file);
    
  } catch (error) {
    console.error('Document analysis failed:', error);
    throw error;
  }
};

/**
 * Transform AWS Textract response to UI-friendly format
 * @param {Object} awsResult - Raw AWS Textract result
 * @param {File} file - Original file object
 * @returns {Object} Transformed result for UI
 */
const transformAnalysisResult = (awsResult, file) => {
  const extractedFields = [];
  
  // Process AWS Textract blocks
  if (awsResult.Blocks) {
    awsResult.Blocks.forEach(block => {
      if (block.BlockType === 'KEY_VALUE_SET' && block.EntityTypes?.includes('KEY')) {
        const keyText = extractTextFromBlock(block, awsResult.Blocks);
        const valueBlock = findValueBlock(block, awsResult.Blocks);
        const valueText = valueBlock ? extractTextFromBlock(valueBlock, awsResult.Blocks) : '';
        
        if (keyText && valueText) {
          extractedFields.push({
            key: cleanFieldName(keyText),
            value: valueText,
            confidence: Math.round(block.Confidence || 0),
            isPii: detectPII(keyText, valueText),
            blockId: block.Id
          });
        }
      }
    });
  }
  
  // Add document type detection
  const documentType = detectDocumentType(extractedFields, file.name);
  
  // Add family member suggestions
  const familyMemberSuggestions = suggestFamilyMembers(extractedFields);
  
  return {
    extractedFields: extractedFields.slice(0, 10), // Limit to top 10 fields
    documentType,
    confidence: calculateOverallConfidence(extractedFields),
    suggestions: {
      category: suggestCategory(documentType, extractedFields),
      familyMembers: familyMemberSuggestions,
      tags: suggestTags(extractedFields, file.name)
    },
    metadata: {
      fileName: file.name,
      fileSize: file.size,
      fileType: file.type,
      analysisDate: new Date().toISOString(),
      processingTime: awsResult.processingTime || 0
    }
  };
};

/**
 * Extract text content from AWS Textract block
 */
const extractTextFromBlock = (block, allBlocks) => {
  if (block.Text) {
    return block.Text.trim();
  }
  
  if (block.Relationships) {
    const childRelation = block.Relationships.find(rel => rel.Type === 'CHILD');
    if (childRelation) {
      return childRelation.Ids
        .map(id => allBlocks.find(b => b.Id === id))
        .filter(b => b && b.Text)
        .map(b => b.Text)
        .join(' ')
        .trim();
    }
  }
  
  return '';
};

/**
 * Find corresponding value block for a key block
 */
const findValueBlock = (keyBlock, allBlocks) => {
  if (!keyBlock.Relationships) return null;
  
  const valueRelation = keyBlock.Relationships.find(rel => rel.Type === 'VALUE');
  if (!valueRelation) return null;
  
  return allBlocks.find(block => 
    valueRelation.Ids.includes(block.Id) && 
    block.EntityTypes?.includes('VALUE')
  );
};

/**
 * Clean and normalize field names
 */
const cleanFieldName = (fieldName) => {
  return fieldName
    .replace(/[:\-_]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim()
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
};

/**
 * Detect if field contains personally identifiable information
 */
const detectPII = (key, value) => {
  const piiKeywords = [
    'name', 'address', 'phone', 'email', 'ssn', 'social security',
    'license', 'id', 'birth', 'date of birth', 'dob'
  ];
  
  const keyLower = key.toLowerCase();
  return piiKeywords.some(keyword => keyLower.includes(keyword));
};

/**
 * Detect document type based on extracted fields and filename
 */
const detectDocumentType = (fields, fileName) => {
  const fieldTexts = fields.map(f => `${f.key} ${f.value}`).join(' ').toLowerCase();
  const fileNameLower = fileName.toLowerCase();
  
  if (fieldTexts.includes('driver') || fieldTexts.includes('license') || fileNameLower.includes('license')) {
    return 'Driver License';
  }
  
  if (fieldTexts.includes('social security') || fieldTexts.includes('ssa')) {
    return 'Social Security Document';
  }
  
  if (fieldTexts.includes('birth certificate') || fieldTexts.includes('born')) {
    return 'Birth Certificate';
  }
  
  if (fieldTexts.includes('passport')) {
    return 'Passport';
  }
  
  if (fieldTexts.includes('insurance') || fieldTexts.includes('policy')) {
    return 'Insurance Document';
  }
  
  if (fieldTexts.includes('medical') || fieldTexts.includes('health')) {
    return 'Medical Record';
  }
  
  return 'Identity Document';
};

/**
 * Calculate overall confidence score
 */
const calculateOverallConfidence = (fields) => {
  if (fields.length === 0) return 0;
  
  const totalConfidence = fields.reduce((sum, field) => sum + field.confidence, 0);
  return Math.round(totalConfidence / fields.length);
};

/**
 * Suggest document category
 */
const suggestCategory = (documentType, fields) => {
  const categoryMap = {
    'Driver License': 'Legal',
    'Social Security Document': 'Legal',
    'Birth Certificate': 'Legal',
    'Passport': 'Legal',
    'Insurance Document': 'Financial',
    'Medical Record': 'Medical'
  };
  
  return categoryMap[documentType] || 'Personal';
};

/**
 * Suggest family members based on extracted names
 */
const suggestFamilyMembers = (fields) => {
  const nameFields = fields.filter(field => 
    field.key.toLowerCase().includes('name') && 
    field.value.length > 2 &&
    !field.value.toLowerCase().includes('organization')
  );
  
  return nameFields.map(field => ({
    name: field.value,
    confidence: field.confidence,
    suggestedRole: 'Family Member',
    source: field.key
  }));
};

/**
 * Suggest tags based on content
 */
const suggestTags = (fields, fileName) => {
  const tags = new Set();
  
  // Add document type tags
  fields.forEach(field => {
    const keyLower = field.key.toLowerCase();
    const valueLower = field.value.toLowerCase();
    
    if (keyLower.includes('license') || valueLower.includes('license')) {
      tags.add('License');
    }
    if (keyLower.includes('medical') || valueLower.includes('medical')) {
      tags.add('Medical');
    }
    if (keyLower.includes('insurance') || valueLower.includes('insurance')) {
      tags.add('Insurance');
    }
  });
  
  // Add year tags
  const currentYear = new Date().getFullYear();
  const yearMatch = fileName.match(/\b(19|20)\d{2}\b/);
  if (yearMatch) {
    tags.add(yearMatch[0]);
  }
  
  return Array.from(tags);
};

/**
 * Enhanced upload workflow combining upload and analysis
 * @param {File} file - File to upload and analyze
 * @param {Function} onProgress - Progress callback
 * @param {Function} onStateChange - State change callback
 * @returns {Promise} Complete workflow result
 */
export const enhancedUploadWorkflow = async (file, onProgress, onStateChange) => {
  try {
    // Phase 1: Upload file
    onStateChange('uploading');
    const uploadResult = await uploadFileWithProgress(file, onProgress);
    
    // Phase 2: Start AI analysis
    onStateChange('processing');
    const analysisResult = await analyzeDocumentWithAI(uploadResult.fileId, file);
    
    // Phase 3: Complete
    onStateChange('complete');
    
    return {
      upload: uploadResult,
      analysis: analysisResult,
      success: true
    };
    
  } catch (error) {
    onStateChange('error');
    throw error;
  }
};

/**
 * Validate file before upload
 * @param {File} file - File to validate
 * @returns {Object} Validation result
 */
export const validateFile = (file) => {
  const maxSize = 10 * 1024 * 1024; // 10MB
  const allowedTypes = [
    'application/pdf',
    'image/jpeg',
    'image/jpg', 
    'image/png',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
  ];
  
  const errors = [];
  
  if (!file) {
    errors.push('No file selected');
  } else {
    if (file.size > maxSize) {
      errors.push('File size must be less than 10MB');
    }
    
    if (!allowedTypes.includes(file.type)) {
      errors.push('File type not supported. Please use PDF, JPG, PNG, or DOC files.');
    }
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
};

// Export all functions
export default {
  uploadFileWithProgress,
  analyzeDocumentWithAI,
  enhancedUploadWorkflow,
  validateFile
};
