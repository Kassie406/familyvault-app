Awesome—let’s ship two high-impact, “production-grade” pieces for your console:

Tamper-evident Audit Log (with before/after diffs)

Coupons v2 (stacking rules, caps, scheduling)

I’ll assume Node/Express + PostgreSQL + React. Copy/paste the bits you need. Everything is namespaced under your admin console (console.familycirclesecure.com) and guarded by RBAC.

1) Tamper-evident Audit Log (with diffs)
DB schema (PostgreSQL)
-- 001_audit_log.sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE audit_log (
  id                UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  ts                TIMESTAMPTZ NOT NULL DEFAULT now(),
  actor_user_id     UUID NOT NULL,
  actor_email       TEXT NOT NULL,
  actor_role        TEXT NOT NULL,               -- ADMIN, PRESIDENT, etc.
  actor_ip          INET,                        -- captured from req.ip
  action            TEXT NOT NULL,               -- e.g. 'coupon.update'
  object_type       TEXT NOT NULL,               -- 'coupon', 'plan', 'user', ...
  object_id         TEXT NOT NULL,               -- store as text; can be UUID/slug/int
  before            JSONB,                       -- nullable; snapshot before change
  after             JSONB,                       -- nullable; snapshot after change
  reason            TEXT,                        -- optional “why” for risky edits
  tamper_hash       TEXT NOT NULL,               -- hash chaining for immutability
  prev_tamper_hash  TEXT                         -- previous row's hash
);

CREATE INDEX audit_log_ts_idx ON audit_log(ts DESC);
CREATE INDEX audit_log_actor_idx ON audit_log(actor_user_id);
CREATE INDEX audit_log_object_idx ON audit_log(object_type, object_id);

Audit utilities (hash chain + writer)
// src/audit/audit.js
import crypto from 'crypto';
import db from '../db.js'; // pg pool

export async function getLastTamperHash() {
  const { rows } = await db.query(
    `SELECT tamper_hash FROM audit_log ORDER BY ts DESC LIMIT 1`
  );
  return rows[0]?.tamper_hash || null;
}

function computeHash(payload) {
  return crypto.createHash('sha256').update(JSON.stringify(payload)).digest('hex');
}

/**
 * Write an audit log entry with tamper-evident chaining.
 * @param {Object} ctx - { userId, email, role, ip }
 * @param {Object} entry - { action, objectType, objectId, before, after, reason }
 */
export async function writeAudit(ctx, entry) {
  const prev = await getLastTamperHash();

  const corePayload = {
    ts: new Date().toISOString(),
    actor_user_id: ctx.userId,
    actor_email: ctx.email,
    actor_role: ctx.role,
    actor_ip: ctx.ip,
    action: entry.action,
    object_type: entry.objectType,
    object_id: String(entry.objectId),
    before: entry.before || null,
    after: entry.after || null,
    reason: entry.reason || null,
    prev_tamper_hash: prev || null,
  };

  const tamper_hash = computeHash(corePayload);
  await db.query(
    `INSERT INTO audit_log
    (id, ts, actor_user_id, actor_email, actor_role, actor_ip, action,
     object_type, object_id, before, after, reason, tamper_hash, prev_tamper_hash)
     VALUES (uuid_generate_v4(), $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13)`,
    [
      corePayload.ts,
      corePayload.actor_user_id,
      corePayload.actor_email,
      corePayload.actor_role,
      corePayload.actor_ip,
      corePayload.action,
      corePayload.object_type,
      corePayload.object_id,
      corePayload.before,
      corePayload.after,
      corePayload.reason,
      tamper_hash,
      corePayload.prev_tamper_hash,
    ]
  );
}

Express middleware (RBAC + audit helper)
// src/mw/requireAdmin.js
export function requireAdmin(req, res, next) {
  const user = req.user; // set by your auth middleware
  if (!user || !['ADMIN', 'PRESIDENT'].includes(user.role)) {
    return res.status(403).json({ error: 'Forbidden' });
  }
  return next();
}

// Attach audit context to request (for convenience)
export function attachAuditCtx(req, res, next) {
  req.auditCtx = {
    userId: req.user.id,
    email: req.user.email,
    role: req.user.role,
    ip: req.ip,
  };
  next();
}

Audit API (read-only)
// src/routes/admin/audit.js
import express from 'express';
import db from '../../db.js';
import { requireAdmin } from '../../mw/requireAdmin.js';

const router = express.Router();

router.get('/', requireAdmin, async (req, res) => {
  const { limit = 100, cursor } = req.query;
  const params = [];
  let sql = `SELECT * FROM audit_log`;
  if (cursor) {
    params.push(cursor);
    sql += ` WHERE ts < (SELECT ts FROM audit_log WHERE id = $${params.length})`;
  }
  params.push(Number(limit));
  sql += ` ORDER BY ts DESC LIMIT $${params.length}`;

  const { rows } = await db.query(sql, params);
  res.json({ items: rows });
});

export default router;

React Admin: Audit Log page (minimal)
// src/console/pages/AuditLog.jsx
import { useEffect, useState } from 'react';
import DiffViewer from 'react-json-view'; // or a simple custom component

export default function AuditLog() {
  const [items, setItems] = useState([]);

  useEffect(() => {
    fetch('/admin/audit?limit=100', { credentials: 'include' })
      .then(r => r.json()).then(d => setItems(d.items || []));
  }, []);

  return (
    <div>
      <h1>Audit Log</h1>
      <table className="table">
        <thead>
          <tr>
            <th>Time</th><th>Actor</th><th>Action</th><th>Object</th><th>Diff</th>
          </tr>
        </thead>
        <tbody>
          {items.map(row => (
            <tr key={row.id}>
              <td>{new Date(row.ts).toLocaleString()}</td>
              <td>{row.actor_email} ({row.actor_role})</td>
              <td>{row.action}</td>
              <td>{row.object_type}/{row.object_id}</td>
              <td>
                <details>
                  <summary>View</summary>
                  <pre>Before: {JSON.stringify(row.before, null, 2)}</pre>
                  <pre>After : {JSON.stringify(row.after, null, 2)}</pre>
                </details>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}


Use it: call writeAudit(req.auditCtx, { action: 'coupon.update', objectType: 'coupon', objectId: id, before, after, reason }) whenever a privileged change happens.

2) Coupons v2 (stacking, caps, scheduling)
DB schema
-- 002_coupons_v2.sql
CREATE TYPE coupon_type AS ENUM ('percent', 'amount', 'free_trial_days');

CREATE TABLE coupon_campaigns (
  id             UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name           TEXT NOT NULL,
  starts_at      TIMESTAMPTZ,
  ends_at        TIMESTAMPTZ,
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE coupons (
  id                UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  code              TEXT UNIQUE NOT NULL,
  campaign_id       UUID REFERENCES coupon_campaigns(id),
  type              coupon_type NOT NULL,
  value             NUMERIC(12,2) NOT NULL,     -- percent (0-100), amount (cents), or days
  currency          TEXT,                       -- only for 'amount'
  max_redemptions   INT,                        -- global cap
  per_user_limit    INT DEFAULT 1,              -- per user cap
  allow_stacking    BOOLEAN DEFAULT FALSE,
  min_subtotal_cents INT,                       -- optional rule
  allowed_plan_ids  TEXT[],                     -- whitelist of plan IDs
  denied_plan_ids   TEXT[],                     -- blacklist (takes precedence)
  starts_at         TIMESTAMPTZ,
  ends_at           TIMESTAMPTZ,
  is_recurring      BOOLEAN DEFAULT FALSE,      -- apply every cycle or once
  metadata          JSONB,
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
  archived          BOOLEAN DEFAULT FALSE
);

CREATE TABLE coupon_redemptions (
  id              UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  coupon_id       UUID NOT NULL REFERENCES coupons(id),
  user_id         UUID NOT NULL,
  org_id          UUID,
  plan_id         TEXT,
  order_id        TEXT,
  redeemed_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  amount_cents    INT,                          -- monetary effect if known
  UNIQUE (coupon_id, user_id, order_id)
);

CREATE INDEX coupon_code_idx ON coupons(code);
CREATE INDEX coupon_redemptions_coupon_idx ON coupon_redemptions(coupon_id);

Validation helpers (server)
// src/coupons/validate.js
export function isActive(coupon, now = new Date()) {
  if (coupon.archived) return false;
  if (coupon.starts_at && new Date(coupon.starts_at) > now) return false;
  if (coupon.ends_at && new Date(coupon.ends_at) < now) return false;
  return true;
}

export function canApplyToPlan(coupon, planId) {
  if (coupon.denied_plan_ids?.includes(planId)) return false;
  if (coupon.allowed_plan_ids && coupon.allowed_plan_ids.length > 0) {
    return coupon.allowed_plan_ids.includes(planId);
  }
  return true;
}

Admin API (create/update/evaluate/redeem)
// src/routes/admin/coupons.js
import express from 'express';
import db from '../../db.js';
import { requireAdmin, attachAuditCtx } from '../../mw/requireAdmin.js';
import { writeAudit } from '../../audit/audit.js';
import { isActive, canApplyToPlan } from '../../coupons/validate.js';

const router = express.Router();

// LIST
router.get('/', requireAdmin, async (req, res) => {
  const { rows } = await db.query(
    `SELECT c.*, 
      (SELECT COUNT(*)::int FROM coupon_redemptions r WHERE r.coupon_id = c.id) AS redemption_count
     FROM coupons c WHERE archived = FALSE ORDER BY created_at DESC`
  );
  res.json({ items: rows });
});

// CREATE
router.post('/', requireAdmin, attachAuditCtx, async (req, res) => {
  const c = req.body;
  const { rows } = await db.query(
    `INSERT INTO coupons (code, campaign_id, type, value, currency, max_redemptions, per_user_limit,
      allow_stacking, min_subtotal_cents, allowed_plan_ids, denied_plan_ids, starts_at, ends_at,
      is_recurring, metadata)
     VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15)
     RETURNING *`,
    [
      c.code, c.campaign_id || null, c.type, c.value, c.currency || null, c.max_redemptions || null,
      c.per_user_limit ?? 1, c.allow_stacking ?? false, c.min_subtotal_cents || null,
      c.allowed_plan_ids || null, c.denied_plan_ids || null,
      c.starts_at || null, c.ends_at || null, c.is_recurring ?? false, c.metadata || {}
    ]
  );
  await writeAudit(req.auditCtx, {
    action: 'coupon.create', objectType: 'coupon', objectId: rows[0].id, before: null, after: rows[0]
  });
  res.status(201).json(rows[0]);
});

// UPDATE
router.put('/:id', requireAdmin, attachAuditCtx, async (req, res) => {
  const id = req.params.id;
  const before = (await db.query(`SELECT * FROM coupons WHERE id=$1`, [id])).rows[0];
  if (!before) return res.status(404).json({ error: 'Not found' });

  const c = req.body;
  const { rows } = await db.query(
    `UPDATE coupons SET
       code=$1, campaign_id=$2, type=$3, value=$4, currency=$5,
       max_redemptions=$6, per_user_limit=$7, allow_stacking=$8, min_subtotal_cents=$9,
       allowed_plan_ids=$10, denied_plan_ids=$11, starts_at=$12, ends_at=$13,
       is_recurring=$14, metadata=$15
     WHERE id=$16
     RETURNING *`,
    [
      c.code, c.campaign_id || null, c.type, c.value, c.currency || null,
      c.max_redemptions || null, c.per_user_limit ?? 1, c.allow_stacking ?? false,
      c.min_subtotal_cents || null, c.allowed_plan_ids || null, c.denied_plan_ids || null,
      c.starts_at || null, c.ends_at || null, c.is_recurring ?? false, c.metadata || {}, id
    ]
  );
  const after = rows[0];
  await writeAudit(req.auditCtx, {
    action: 'coupon.update', objectType: 'coupon', objectId: id, before, after,
    reason: req.body.reason || null
  });
  res.json(after);
});

// ARCHIVE
router.post('/:id/archive', requireAdmin, attachAuditCtx, async (req, res) => {
  const id = req.params.id;
  const before = (await db.query(`SELECT * FROM coupons WHERE id=$1`, [id])).rows[0];
  await db.query(`UPDATE coupons SET archived=TRUE WHERE id=$1`, [id]);
  await writeAudit(req.auditCtx, {
    action: 'coupon.archive', objectType: 'coupon', objectId: id, before, after: { ...before, archived: true }
  });
  res.json({ ok: true });
});

// PREVIEW / EVALUATE (apply rules without redeeming)
router.post('/evaluate', requireAdmin, async (req, res) => {
  const { code, planId, subtotalCents, userId } = req.body;
  const { rows } = await db.query(`SELECT * FROM coupons WHERE code=$1 AND archived=FALSE`, [code.toUpperCase()]);
  const coupon = rows[0];
  if (!coupon) return res.status(404).json({ error: 'Invalid code' });
  if (!isActive(coupon)) return res.status(400).json({ error: 'Coupon not active' });
  if (coupon.min_subtotal_cents && subtotalCents < coupon.min_subtotal_cents) {
    return res.status(400).json({ error: 'Subtotal too low' });
  }
  if (!canApplyToPlan(coupon, planId)) return res.status(400).json({ error: 'Not valid for this plan' });

  // Per-user cap
  const pu = await db.query(`SELECT COUNT(*)::int AS cnt FROM coupon_redemptions WHERE coupon_id=$1 AND user_id=$2`, [coupon.id, userId]);
  if (coupon.per_user_limit && pu.rows[0].cnt >= coupon.per_user_limit) {
    return res.status(400).json({ error: 'Per-user limit reached' });
  }
  // Global cap
  if (coupon.max_redemptions) {
    const g = await db.query(`SELECT COUNT(*)::int AS cnt FROM coupon_redemptions WHERE coupon_id=$1`, [coupon.id]);
    if (g.rows[0].cnt >= coupon.max_redemptions) {
      return res.status(400).json({ error: 'Max redemptions reached' });
    }
  }

  // Compute effect
  let discountCents = 0;
  if (coupon.type === 'percent') discountCents = Math.floor(subtotalCents * (Number(coupon.value) / 100));
  if (coupon.type === 'amount') discountCents = Math.min(subtotalCents, Number(coupon.value));
  // free_trial_days handled by billing layer

  res.json({
    ok: true,
    coupon,
    discountCents,
    isRecurring: coupon.is_recurring,
  });
});

// REDEEM (records redemption)
router.post('/redeem', requireAdmin, attachAuditCtx, async (req, res) => {
  const { code, userId, orgId, planId, orderId, subtotalCents } = req.body;
  const { rows } = await db.query(`SELECT * FROM coupons WHERE code=$1 AND archived=FALSE`, [code.toUpperCase()]);
  const coupon = rows[0];
  if (!coupon) return res.status(404).json({ error: 'Invalid code' });

  // reuse evaluate logic quickly
  const preview = await (await fetch('http://localhost/internal/admin/coupons/evaluate', {
    method: 'POST', headers: { 'content-type':'application/json' },
    body: JSON.stringify({ code, planId, subtotalCents, userId })
  })).json();
  if (!preview.ok) return res.status(400).json(preview);

  const { rows: ins } = await db.query(
    `INSERT INTO coupon_redemptions (coupon_id,user_id,org_id,plan_id,order_id,amount_cents)
     VALUES ($1,$2,$3,$4,$5,$6) RETURNING *`,
    [coupon.id, userId, orgId || null, planId || null, orderId || null, preview.discountCents || null]
  );

  await writeAudit(req.auditCtx, {
    action: 'coupon.redeem', objectType: 'coupon', objectId: coupon.id,
    before: null, after: { redemption_id: ins[0].id, userId, orderId }
  });

  res.json({ ok: true, redemption: ins[0], discountCents: preview.discountCents });
});

export default router;


Note: In your real app, redemption should happen in your checkout/billing flow (Stripe or internal billing), but the evaluation + policy checks above are the same.

React Admin: Coupon List & Form (minimal)
// src/console/pages/Coupons.jsx
import { useEffect, useState } from 'react';

export default function Coupons() {
  const [items, setItems] = useState([]);
  const [openForm, setOpenForm] = useState(false);

  useEffect(() => {
    fetch('/admin/coupons', { credentials: 'include' })
      .then(r => r.json()).then(d => setItems(d.items || []));
  }, []);

  return (
    <div>
      <div className="headerRow">
        <h1>Coupons</h1>
        <button className="btn btn-primary" onClick={() => setOpenForm(true)}>Create Coupon</button>
      </div>
      <table className="table">
        <thead>
          <tr>
            <th>Code</th><th>Type</th><th>Value</th><th>Active Window</th><th>Redemptions</th><th>Stack</th><th></th>
          </tr>
        </thead>
        <tbody>
          {items.map(c => (
            <tr key={c.id}>
              <td>{c.code}</td>
              <td>{c.type}</td>
              <td>{c.value}{c.type==='percent'?'%':c.type==='amount'?' '+(c.currency||'¢'):''}</td>
              <td>{c.starts_at?new Date(c.starts_at).toLocaleDateString():'–'} → {c.ends_at?new Date(c.ends_at).toLocaleDateString():'–'}</td>
              <td>{c.redemption_count ?? 0}/{c.max_redemptions ?? '∞'}</td>
              <td>{c.allow_stacking ? 'Yes' : 'No'}</td>
              <td><ArchiveButton id={c.id}/></td>
            </tr>
          ))}
        </tbody>
      </table>

      {openForm && <CouponForm onClose={() => setOpenForm(false)} onSaved={() => location.reload()} />}
    </div>
  );
}

function ArchiveButton({ id }) {
  const archive = async () => {
    if (!confirm('Archive this coupon?')) return;
    await fetch(`/admin/coupons/${id}/archive`, { method:'POST', credentials:'include' });
    location.reload();
  };
  return <button className="btn btn-ghost" onClick={archive}>Archive</button>;
}

// --- Form (simplified) ---
function CouponForm({ onClose, onSaved }) {
  const [form, setForm] = useState({
    code: '', type: 'percent', value: 10, allow_stacking: false,
    max_redemptions: null, per_user_limit: 1, starts_at: null, ends_at: null,
    is_recurring: false, min_subtotal_cents: null, allowed_plan_ids: [], denied_plan_ids: []
  });

  const save = async () => {
    const r = await fetch('/admin/coupons', {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify(form)
    });
    if (r.ok) onSaved();
  };

  return (
    <div className="modal">
      <div className="card">
        <h2>Create Coupon</h2>
        <label>Code <input value={form.code} onChange={e=>setForm({...form, code: e.target.value.toUpperCase()})}/></label>
        <label>Type
          <select value={form.type} onChange={e=>setForm({...form, type: e.target.value})}>
            <option value="percent">Percent</option>
            <option value="amount">Amount (cents)</option>
            <option value="free_trial_days">Free trial (days)</option>
          </select>
        </label>
        <label>Value <input type="number" value={form.value} onChange={e=>setForm({...form, value: Number(e.target.value)})}/></label>
        <label><input type="checkbox" checked={form.allow_stacking} onChange={e=>setForm({...form, allow_stacking:e.target.checked})}/> Allow Stacking</label>
        <label>Max Redemptions <input type="number" value={form.max_redemptions||''} onChange={e=>setForm({...form, max_redemptions: e.target.value?Number(e.target.value):null})}/></label>
        <label>Per User Limit <input type="number" value={form.per_user_limit} onChange={e=>setForm({...form, per_user_limit:Number(e.target.value)})}/></label>
        <label>Starts <input type="datetime-local" onChange={e=>setForm({...form, starts_at: e.target.value})}/></label>
        <label>Ends <input type="datetime-local" onChange={e=>setForm({...form, ends_at: e.target.value})}/></label>
        <div className="row">
          <button className="btn" onClick={onClose}>Cancel</button>
          <button className="btn btn-primary" onClick={save}>Save</button>
        </div>
      </div>
    </div>
  );
}

Stacking policy (server-side)

When applying multiple coupons at checkout, validate:

// example logic
function applyCoupons(subtotalCents, coupons) {
  // Reject if any coupon disallows stacking and there's more than one
  if (coupons.some(c => !c.allow_stacking) && coupons.length > 1) {
    throw new Error('Coupons cannot be stacked');
  }
  // Apply percent first or amount first? pick a deterministic rule
  const percent = coupons.filter(c => c.type==='percent');
  const amount  = coupons.filter(c => c.type==='amount');

  let total = subtotalCents;
  for (const c of percent) total -= Math.floor(total * (Number(c.value)/100));
  for (const c of amount)  total -= Math.min(total, Number(c.value));

  if (total < 0) total = 0;
  return total;
}

Wire-up and nav

Mount routes in Express:

app.use('/admin/audit', auditRouter);
app.use('/admin/coupons', couponsRouter);


Add console sidebar links to:

/console/audit

/console/coupons

Gate with requireAdmin everywhere and show an Impersonation banner if req.session.impersonating === true (nice safety cue).

What you get, right now

Audit Log with:

Actor, IP, role, before/after object snapshots

Tamper-evident hash chain

Read-only API + simple UI table

Coupons v2 with:

Create/Update/Archive

Scheduling, caps, per-user limit

Allowed/denied plans, minimum subtotal

Stacking policy & evaluate endpoint

Redemption recording + audited