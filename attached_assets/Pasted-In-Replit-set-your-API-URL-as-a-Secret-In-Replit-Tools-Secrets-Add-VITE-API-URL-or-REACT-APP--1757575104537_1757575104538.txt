In Replit, set your API URL as a Secret

In Replit: Tools → Secrets

Add VITE_API_URL (or REACT_APP_API_URL if CRA) = your Lambda Function URL.

Update your front-end analyzeDocument (the React code that currently “mocks” analysis):

// Vite: import.meta.env.VITE_API_URL
// CRA:  process.env.REACT_APP_API_URL
const API_URL = import.meta?.env?.VITE_API_URL || process.env.REACT_APP_API_URL;

async function fileToBase64(file) {
  const dataUrl = await new Promise((res, rej) => {
    const reader = new FileReader();
    reader.onload = () => res(reader.result);
    reader.onerror = rej;
    reader.readAsDataURL(file);
  });
  // strip "data:image/...;base64," prefix
  return dataUrl.split(',')[1];
}

export async function analyzeDocument(file, docType = 'auto') {
  const fileContent = await fileToBase64(file);

  const resp = await fetch(API_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      fileContent,
      filename: file.name,
      documentType: docType // 'identity' for DL/Passport/SSN, 'form' for bills/insurance
    })
  });

  if (!resp.ok) {
    const text = await resp.text();
    throw new Error(`API ${resp.status}: ${text}`);
  }
  return await resp.json();
}


Wire the button
Call analyzeDocument(uploadedFile, selectedDocType) from your “Analyze with AI” button (you already have that in your UI—just swap in this function).

Try a small file first (to stay under function-URL size). If you hit a red error bar in your app, open the CloudWatch Logs link from Lambda for the exact message.

Production-ready path: API Gateway (recommended)

Handles bigger payloads (up to 10 MB) and proper HTTP behavior.

Create API (REST) in API Gateway

Resource: /analyze

Method: POST → Lambda proxy integration → select your Lambda

Enable CORS for POST, OPTIONS and Content-Type

Deploy the API (new stage, e.g., prod)

Copy the Invoke URL (e.g. https://abc123.execute-api.us-east-1.amazonaws.com/prod/analyze)
Put it in Replit Secrets as VITE_API_URL.

Lambda response CORS (still add headers as shown above).
API Gateway + Lambda headers together make CORS smooth.

If your images are larger than 10 MB, switch to the S3 pre-signed URL flow:

Frontend asks your backend for a pre-signed PUT URL.

Upload file directly to S3 from the browser (no size pain).

Send a tiny JSON to Lambda with { s3Bucket, s3Key, documentType }.

Lambda reads from S3 and runs Textract.
This needs S3 permissions (s3:PutObject, s3:GetObject) on your Lambda role.