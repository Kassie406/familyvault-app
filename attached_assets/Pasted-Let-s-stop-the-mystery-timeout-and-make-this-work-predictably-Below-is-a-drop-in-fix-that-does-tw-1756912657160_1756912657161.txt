Let’s stop the “mystery timeout” and make this work predictably. Below is a drop-in fix that does two things:

Server: guarantees the regenerate endpoint always returns a fast JSON result (never hangs), with clear logging.

Client: surfaces the real error (401/404/500/HTML) instead of a vague timeout.

Apply the code exactly, redeploy, and test the two URLs I list at the end.

1) Server: fast, deterministic share generation

File: server/index.ts (or your main Express entry)

Add these helpers and endpoints, and make sure they are mounted before any SPA/static fallback:

// ===== MUST be near the top of the file, before SPA fallback =====
import express from 'express';

const app = express();
app.use(express.json());

// Health + probe
app.get('/api/healthz', (_req, res) => res.json({ ok: true, t: Date.now() }));
app.post('/api/test-post', (_req, res) => res.json({ ok: true }));

// Small helper to guarantee we never hang the client
function withTimeout<T>(p: Promise<T>, ms: number, label: string): Promise<T> {
  return new Promise((resolve, reject) => {
    const t = setTimeout(() => reject(new Error(`TIMEOUT ${label} after ${ms}ms`)), ms);
    p.then(v => { clearTimeout(t); resolve(v); }).catch(e => { clearTimeout(t); reject(e); });
  });
}

// === REGENERATE HANDLER (production-safe) ===
// - Logs clearly
// - Uses DB with an explicit timeout
// - Returns JSON error instead of hanging
app.post('/api/credentials/:id/shares/regenerate', async (req, res) => {
  const id = req.params.id;
  const { expiry = '7d', requireLogin = true } = req.body || {};
  const started = Date.now();

  try {
    console.log('[regen] hit', { id, expiry, requireLogin, t: started });

    // ---- REPLACE THIS with your real DB call (Drizzle/Neon) ----
    // Example: create token and upsert into share_links
    const token = crypto.randomBytes(16).toString('base64url');
    const expiresAt = (() => {
      if (expiry === 'never') return null;
      const d = new Date();
      if (expiry === '24h') d.setDate(d.getDate() + 1);
      else if (expiry === '7d') d.setDate(d.getDate() + 7);
      else if (expiry === '30d') d.setDate(d.getDate() + 30);
      return d;
    })();

    // pretend DB work with timeout wrapper:
    await withTimeout(
      Promise.resolve(),        // <-- put your drizzle insert/upsert promise here
      8000,                     // 8s hard cap
      'share_links upsert'
    );

    const url = `${process.env.APP_URL || ''}/share/${token}`;
    console.log('[regen] ok', { id, ms: Date.now() - started, url });
    return res.json({ token, url, expiresAt, requireLogin });
  } catch (err: any) {
    console.error('[regen] fail', { id, ms: Date.now() - started, err: err?.message });
    // Always JSON error (no SPA HTML)
    return res
      .status(/TIMEOUT/.test(err?.message) ? 504 : 500)
      .json({ ok: false, error: err?.message || 'unknown' });
  }
});

// ===== IMPORTANT =====
// Any SPA/static middleware must be registered AFTER the /api/* routes.
// e.g. app.use(express.static('dist')); app.get('*', ... send index.html)


Why this works

If DB or middleware ever stalls, the client receives 504 JSON in ≤ 8s (no silent hang).

Logs are explicit: [regen] ok or [regen] fail.

2) Client: show the real error (no more generic “Timeout”)

File: client/src/pages/family/family-passwords.tsx (where you call regenerate)

Replace your regenerate call with this helper (keeps a 15s cap and shows exact server response):

async function regenerateShareLink(
  credentialId: string,
  opts: { expiry: '24h' | '7d' | '30d' | 'never'; requireLogin: boolean }
) {
  const ctrl = new AbortController();
  const to = setTimeout(() => ctrl.abort(), 15000); // hard cap

  try {
    const res = await fetch(`/api/credentials/${credentialId}/shares/regenerate`, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify(opts),
      signal: ctrl.signal,
    });

    const ct = res.headers.get('content-type') || '';
    const text = await res.text();

    if (!ct.includes('application/json')) {
      throw new Error(`Non-JSON response (likely SPA/HTML). status=${res.status} body=${text.slice(0,120)}`);
    }

    const data = JSON.parse(text);
    if (!res.ok || data?.ok === false) {
      throw new Error(data?.error || `HTTP ${res.status}`);
    }

    return data; // { token, url, ... }
  } catch (e: any) {
    // Bubble up specific message; your toast can show e.message
    throw new Error(e?.message || 'Request failed');
  } finally {
    clearTimeout(to);
  }
}


Then your UI button handler:

setIsGenerating(true);
regenerateShareLink(credentialId, { expiry, requireLogin })
  .then(({ url }) => {
    setShareUrl(url);
    toast.success('Share link created');
  })
  .catch(err => {
    toast.error(`Share generation failed: ${String(err.message)}`);
  })
  .finally(() => setIsGenerating(false));


Now you’ll see exactly why it fails: HTTP 401, Non-JSON response, TIMEOUT share_links upsert, etc.

3) Replit deployment “gotchas” (quick confirm)

Start command runs the API (not just static):

NODE_ENV=production node dist/index.js   # or your compiled entry


Secrets (Deployment level):

NODE_ENV=production
APP_URL=https://portal.familycirclesecure.com
DATABASE_URL=postgres://<neon>
DEV_BYPASS_AUTH=true   # TEMP while you verify routing/DB. Flip false after.


Post-deploy command:

npm run db:push


Smoke tests in the browser:

https://portal.familycirclesecure.com/api/healthz → JSON { ok: true }

DevTools Console:

fetch('/api/test-post', {method:'POST'}).then(r=>r.json()).then(console.log)


→ { ok:true }

If either returns HTML/404 → your SPA is intercepting /api/* or the Start command isn’t running Express.

4) What to do if you still see a toast error

If the error says “Non-JSON response (likely SPA/HTML)” → ensure API routes are above SPA fallback and redeploy.

If HTTP 401 → your session cookie isn’t reaching the API; set cookie Secure; SameSite=Lax and same origin.

If TIMEOUT share_links upsert → your DB call is hanging; check Neon creds and that npm run db:push ran.

Final: two URLs to verify in production

https://portal.familycirclesecure.com/api/healthz → must be JSON

POST /api/test-post from the console snippet above → must be {ok:true}

Once both are good, click Generate again—the server now guarantees a fast JSON reply with a precise error if anything’s off, and your UI will display the exact cause instead of “Timeout”.

If you hit a specific error message after this patch, paste that single error line and I’ll give you the one-liner fix.