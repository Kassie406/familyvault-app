let’s wire Invite → Accept first, then move straight into Documents / Photos CRUD. I’ll give you the DB schema, API contract, and server handler stubs that drop into your existing Node/Express + Drizzle + Postgres stack (Neon). Everything is shaped to power the dashboard counts + “Recent ▾” previews you already have.

1) Invitation Acceptance Flow
1.1 DB (additions)

We already create family_invitations. Add two columns + an index so we can verify + accept quickly.

-- 001_add_invite_accept.sql
ALTER TABLE family_invitations
  ADD COLUMN accepted_at TIMESTAMPTZ,
  ADD COLUMN accepted_by UUID; -- new user_id (future: auth user or light contact)

CREATE INDEX IF NOT EXISTS idx_invite_token ON family_invitations (token);


If you also want to “claim” a profile on accept, make sure family_members has a nullable user_id UUID you can set.

1.2 API contract
GET /api/invitations/:token

Validate token & show who/what the invite is for.

200

{
  "ok": true,
  "invite": {
    "id": "b4e…",
    "familyId": "f12…",
    "memberPreview": {
      "name": "Emma Johnson",
      "role": "Child",
      "avatar": null
    },
    "expiresAt": "2025-10-02T18:30:00Z",
    "status": "pending"          // pending | expired | accepted | revoked
  }
}


4xx

{"ok": false, "error": "invalid_token" | "expired" | "already_accepted"}

POST /api/invitations/:token/accept

Accept the invite. Body is minimal; you can extend with display name, avatar, etc.

Body

{
  "acceptingUserId": "auth-user-id-or-null",
  "relationship": "Child"        // optional override; else use invite payload
}


200

{
  "ok": true,
  "familyId": "f12…",
  "member": {
    "id": "mem_…",
    "name": "Emma Johnson",
    "role": "Child"
  }
}


Side effects:
• set accepted_at, accepted_by on family_invitations
• upsert a family_members row if not present & link user_id if you have auth
• insert an activity log: INVITE_ACCEPTED

1.3 Server handlers (Express + Drizzle style)
// routes/invitations.ts
import { Router } from "express";
import { db } from "../db";
import { familyInvitations, familyMembers, activities } from "../db/schema";
import { eq } from "drizzle-orm";
import { z } from "zod";

const r = Router();

r.get("/:token", async (req, res) => {
  const token = req.params.token.trim();
  const [inv] = await db.select().from(familyInvitations).where(eq(familyInvitations.token, token)).limit(1);

  if (!inv) return res.status(404).json({ ok:false, error:"invalid_token" });

  const now = new Date();
  if (inv.expiresAt && inv.expiresAt < now) return res.status(410).json({ ok:false, error:"expired" });
  if (inv.acceptedAt)          return res.status(409).json({ ok:false, error:"already_accepted" });
  if (inv.revokedAt)           return res.status(410).json({ ok:false, error:"revoked" });

  res.json({
    ok: true,
    invite: {
      id: inv.id,
      familyId: inv.familyId,
      memberPreview: inv.memberPreview, // whatever you stored
      expiresAt: inv.expiresAt,
      status: "pending"
    }
  });
});

const acceptBody = z.object({
  acceptingUserId: z.string().uuid().nullable().optional(),
  relationship: z.string().optional()
});

r.post("/:token/accept", async (req, res) => {
  const token = req.params.token.trim();
  const parse = acceptBody.safeParse(req.body);
  if (!parse.success) return res.status(400).json({ ok:false, error:"invalid_body" });

  const [inv] = await db.select().from(familyInvitations).where(eq(familyInvitations.token, token)).limit(1);
  if (!inv) return res.status(404).json({ ok:false, error:"invalid_token" });

  const now = new Date();
  if (inv.expiresAt && inv.expiresAt < now) return res.status(410).json({ ok:false, error:"expired" });
  if (inv.acceptedAt)          return res.status(409).json({ ok:false, error:"already_accepted" });
  if (inv.revokedAt)           return res.status(410).json({ ok:false, error:"revoked" });

  // Create or attach a member
  const newMember = await db.insert(familyMembers).values({
    familyId: inv.familyId,
    name: inv.memberPreview?.name ?? "New Member",
    role: parse.data.relationship ?? inv.memberPreview?.role ?? "Member",
    userId: parse.data.acceptingUserId ?? null
  }).returning();

  await db.update(familyInvitations)
    .set({ acceptedAt: now, acceptedBy: parse.data.acceptingUserId ?? null })
    .where(eq(familyInvitations.id, inv.id));

  await db.insert(activities).values({
    familyId: inv.familyId,
    type: "INVITE_ACCEPTED",
    actorId: parse.data.acceptingUserId ?? null,
    payload: { invitedMemberId: newMember[0].id, token }
  });

  res.json({ ok:true, familyId: inv.familyId, member: newMember[0] });
});

export default r;


Frontend: route shared invite links like /share/invite/:token to a compact page that calls GET → shows who invited, and on Accept calls POST, then redirect to the appropriate Family IDs or Dashboard.

2) Documents & Photos CRUD (with uploads)

We’ll keep it simple + scalable:

Binary files live in storage (S3, Cloudflare R2, or Replit’s storage).

DB stores metadata + presigned URLs for upload/download.

Everything is namespaced by family_id.

2.1 DB schema
-- 002_docs_photos.sql
CREATE TABLE documents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  family_id UUID NOT NULL,
  owner_id UUID,                   -- family_members.id
  title TEXT NOT NULL,
  category TEXT,                   -- "Legal", "Finance", "Insurance", …
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE document_files (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
  storage_key TEXT NOT NULL,       -- e.g. s3 key
  mime TEXT,
  size BIGINT,
  sha256 TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_docs_family ON documents (family_id, created_at DESC);

CREATE TABLE photos (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  family_id UUID NOT NULL,
  owner_id UUID,
  caption TEXT,
  taken_at TIMESTAMPTZ,
  storage_key TEXT NOT NULL,
  width INT,
  height INT,
  size BIGINT,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX idx_photos_family ON photos (family_id, created_at DESC);


Counts for the dashboard come from COUNT(*) FROM documents and COUNT(*) FROM photos WHERE family_id = $1, and the “Recent ▾” previews use ORDER BY created_at DESC LIMIT 5.

2.2 Storage helpers

If you’re on S3/R2:

POST /api/storage/presign → returns { url, fields, key } for direct browser upload.

After upload completes, call your POST /api/documents/:id/files with { key, size, mime, sha256 }.

(If you prefer server-proxy upload, you can switch to multipart/form-data and stream to storage in the API instead.)

2.3 API contract (Documents)
GET /api/families/:familyId/documents?category=&q=&limit=&cursor=

List documents with cursor pagination.

200

{
  "ok": true,
  "items": [
    { "id":"doc1", "title":"Homeowners Policy", "category":"Insurance", "filesCount":1, "createdAt":"…" }
  ],
  "nextCursor": "eyJh…"
}

POST /api/families/:familyId/documents

Create a document shell (metadata first).

Body

{ "title":"Homeowners Policy", "category":"Insurance", "notes":"State Farm 2025" }


200

{ "ok":true, "document": { "id":"doc1", "title":"Homeowners Policy", "filesCount":0 } }

POST /api/documents/:documentId/files

Attach an uploaded file (after presign + upload).

Body

{ "storageKey":"fam/abc/doc/doc1/file/xyz.pdf", "size": 234567, "mime":"application/pdf", "sha256":"…" }


200

{ "ok": true, "file": { "id":"f1", "storageKey":"…", "mime":"application/pdf", "size":234567 } }

GET /api/documents/:documentId

Return document + its files (and signed download URLs if you want).

PATCH /api/documents/:documentId

Update title/category/notes.

DELETE /api/documents/:documentId

Delete doc + files (and queue storage deletions).

2.4 API contract (Photos)
GET /api/families/:familyId/photos?limit=&cursor=

Recent photos (for dashboard & gallery).

POST /api/families/:familyId/photos

Create a new photo record after upload.

Body

{
  "storageKey":"fam/abc/photos/2025/09/01/uuid.jpg",
  "caption":"Vacation",
  "takenAt":"2025-08-14T18:22:00Z",
  "width": 3024, "height": 4032, "size": 1453221
}

DELETE /api/photos/:photoId

Deletes photo + storage object.

Optional: add Albums table if you want grouping later:

CREATE TABLE photo_albums (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  family_id UUID NOT NULL,
  title TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE TABLE photo_album_items (
  album_id UUID REFERENCES photo_albums(id) ON DELETE CASCADE,
  photo_id UUID REFERENCES photos(id) ON DELETE CASCADE,
  PRIMARY KEY (album_id, photo_id)
);

2.5 Handlers (compact stubs)
// routes/documents.ts
import { Router } from "express";
import { db } from "../db";
import { documents, documentFiles, activities } from "../db/schema";
import { and, eq, desc, ilike } from "drizzle-orm";
import { z } from "zod";

const r = Router();

r.get("/families/:fid/documents", async (req, res) => {
  const fid = req.params.fid;
  const q = (req.query.q as string) ?? "";
  const rows = await db.query.documents.findMany({
    where: q ? and(eq(documents.familyId, fid), ilike(documents.title, `%${q}%`)) : eq(documents.familyId, fid),
    orderBy: desc(documents.createdAt),
    limit: Number(req.query.limit ?? 25)
  });
  res.json({ ok:true, items: rows });
});

r.post("/families/:fid/documents", async (req, res) => {
  const fid = req.params.fid;
  const Doc = z.object({ title:z.string().min(1), category:z.string().optional(), notes:z.string().optional() });
  const body = Doc.parse(req.body);

  const [doc] = await db.insert(documents).values({ familyId: fid, title: body.title, category: body.category ?? null, notes: body.notes ?? null }).returning();

  await db.insert(activities).values({ familyId: fid, type: "DOC_CREATED", payload: { documentId: doc.id, title: doc.title } });

  res.json({ ok:true, document: doc });
});

r.post("/documents/:id/files", async (req, res) => {
  const id = req.params.id;
  const File = z.object({ storageKey:z.string().min(1), mime:z.string().optional(), size:z.number().int().nonnegative(), sha256:z.string().optional() });
  const body = File.parse(req.body);

  const [file] = await db.insert(documentFiles).values({ documentId: id, storageKey: body.storageKey, mime: body.mime ?? null, size: body.size, sha256: body.sha256 ?? null }).returning();
  res.json({ ok:true, file });
});

export default r;

// routes/photos.ts
import { Router } from "express";
import { db } from "../db";
import { photos, activities } from "../db/schema";
import { eq, desc } from "drizzle-orm";
import { z } from "zod";
const r = Router();

r.get("/families/:fid/photos", async (req, res) => {
  const fid = req.params.fid;
  const rows = await db.select().from(photos).where(eq(photos.familyId, fid)).orderBy(desc(photos.createdAt)).limit(Number(req.query.limit ?? 36));
  res.json({ ok:true, items: rows });
});

r.post("/families/:fid/photos", async (req, res) => {
  const fid = req.params.fid;
  const P = z.object({
    storageKey:z.string().min(1),
    caption:z.string().optional(),
    takenAt:z.string().datetime().optional(),
    width:z.number().int().optional(),
    height:z.number().int().optional(),
    size:z.number().int().optional()
  });
  const body = P.parse(req.body);

  const [ph] = await db.insert(photos).values({
    familyId: fid,
    storageKey: body.storageKey,
    caption: body.caption ?? null,
    takenAt: body.takenAt ? new Date(body.takenAt) : null,
    width: body.width ?? null,
    height: body.height ?? null,
    size: body.size ?? null
  }).returning();

  await db.insert(activities).values({ familyId: fid, type: "PHOTO_ADDED", payload: { photoId: ph.id } });
  res.json({ ok:true, photo: ph });
});

export default r;

2.6 Dashboard wiring

Counts

GET /api/families/:fid/overview → { members: 5, documents: 23, messagesToday: 12, photos: 156 }

Recent dropdowns

GET /api/families/:fid/activities?type=DOC_CREATED|PHOTO_ADDED&limit=5

(You already have an activities table; reuse it.)

2.7 Permissions (quick pass)

Every route reads familyId from path or joins back to ensure the caller belongs to the family.

Documents/Photos creation: require role ≥ Contributor.

Delete: role ≥ Admin or owner_id.

What’s next?

Drop these migrations and run your db:push.

Mount routes in your server (app.use("/api/invitations", invitationsRouter), app.use("/api", documentsRouter), app.use("/api", photosRouter)).

Frontend glue:

Invite page: /invite/:token (GET → show → POST accept → redirect).

Documents: hook the “Upload Document” quick action → create doc → presign → upload → attach file.

Photos: “View Photos” + “Upload” button with the same presign pattern.

Dashboard cards: link to /family/:id/documents and /family/:id/photos.