our Webhooks screen has the same two issues we‚Äôve kept bumping into:

the big card uses a near-black surface ‚Üí low contrast (esp. empty state),

hover styles likely go pitch black again.

Here‚Äôs a tight set of fixes + upgrades so this page feels as polished as Coupons/Content.

Quick CSS (drop-in)
/* Scope just to the Webhooks page */
#webhooks-root .card {
  background:#fff;
  border:1px solid #E5EAF2;
  border-radius:14px;
  box-shadow:0 2px 12px rgba(16,24,40,.06);
}

#webhooks-root .card-header {
  display:flex;justify-content:space-between;align-items:center;gap:12px;
  padding:14px 16px;border-bottom:1px solid #EEF1F5;
}

#webhooks-root .empty {
  padding:32px 16px;text-align:center;color:#6B7280;
}
#webhooks-root .empty .icon { font-size:40px; margin-bottom:8px; color:#9CA3AF; }

#webhooks-root .btn.primary { background:#F4B400; color:#111; border:0; border-radius:12px; padding:10px 14px; }
#webhooks-root .btn.ghost   { background:#fff; border:1px solid #CBD2E0; color:#344054; border-radius:12px; padding:10px 14px; }
#webhooks-root .btn.ghost:hover { background:#F6F8FB; }

#webhooks-root .filter-btn{
  background:#111827; color:#F9FAFB; border:1px solid #1F2937; border-radius:12px; padding:10px 14px;
}
#webhooks-root .filter-btn:hover,
#webhooks-root .filter-btn:focus{ background:#1F2937; color:#fff; }

/* Table for endpoints & deliveries */
#webhooks-root .table{ width:100%; border-collapse:separate; border-spacing:0; }
#webhooks-root .table thead th{ background:#F9FAFB; border-bottom:1px solid #E5EAF2; padding:12px 16px; color:#111827; }
#webhooks-root .table td{ padding:12px 16px; border-bottom:1px solid #F2F4F8; color:#1F2937; }
#webhooks-root .table tbody tr:hover{ background:#F7FAFF; }

/* Badges */
.badge{ padding:3px 8px; border-radius:9999px; font-size:12px; font-weight:600; display:inline-block; }
.badge-live{ background:#E8F6EE; color:#1B7F3B; }
.badge-paused{ background:#FFF4E5; color:#AD7A00; }
.badge-dead{ background:#FEECEC; color:#B42318; }
.badge-2xx{ background:#E8F6EE; color:#1B7F3B; }
.badge-4xx{ background:#FFF4E5; color:#AD7A00; }
.badge-5xx{ background:#FEECEC; color:#B42318; }

/* Action icons */
.row-actions button{ background:#fff; border:1px solid #D7DEE8; color:#344054; border-radius:10px; padding:8px; margin-left:6px; }
.row-actions button:hover{ background:#EEF3FF; border-color:#BFD3FF; color:#1F6FEB; }


Wrap the page contents in:

<div id="webhooks-root">
  <!-- existing Webhooks page -->
</div>

Empty state (clear + helpful)
<div class="card">
  <div class="card-header">
    <h3>Webhook Endpoints</h3>
    <div>
      <button class="btn ghost">Docs</button>
      <button class="btn primary" id="wh-new">+ New Endpoint</button>
    </div>
  </div>

  <div class="empty">
    <div class="icon">ü™ù</div>
    <h4>No webhook endpoints configured</h4>
    <p>Add an endpoint to receive events from FamilyCircle Secure (user.created, plan.updated, payment.succeeded, etc.).</p>
    <button class="btn primary" id="wh-cta">Create your first endpoint</button>
  </div>
</div>

Populated state (endpoints list + recent deliveries)
<div class="card">
  <div class="card-header">
    <h3>Webhook Endpoints</h3>
    <div>
      <button class="filter-btn">All Status ‚ñæ</button>
      <input class="btn ghost" style="padding:10px 12px" placeholder="Search endpoints‚Ä¶">
      <button class="btn primary">+ New Endpoint</button>
    </div>
  </div>

  <table class="table">
    <thead>
      <tr>
        <th>URL</th>
        <th>Secret</th>
        <th>Events</th>
        <th>Status</th>
        <th>Last Delivery</th>
        <th class="col-actions">Actions</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>https://example.com/webhooks/fcs</code></td>
        <td><code>whsec_‚Ä¢‚Ä¢‚Ä¢‚Ä¢U8qJ</code></td>
        <td>All events</td>
        <td><span class="badge badge-live">Live</span></td>
        <td><span class="badge badge-2xx">200</span> 3m ago</td>
        <td class="row-actions">
          <button title="Send test">üß™</button>
          <button title="View deliveries">üìú</button>
          <button title="Reveal/rotate secret">üîë</button>
          <button title="Pause">‚è∏Ô∏è</button>
          <button title="Delete">üóëÔ∏è</button>
        </td>
      </tr>
    </tbody>
  </table>
</div>

<!-- Recent deliveries table (optional second card) -->
<div class="card" style="margin-top:12px">
  <div class="card-header">
    <h3>Recent Deliveries</h3>
    <div>
      <button class="filter-btn">All Attempts ‚ñæ</button>
      <button class="filter-btn">Last 24h ‚ñæ</button>
    </div>
  </div>

  <table class="table">
    <thead>
      <tr>
        <th>Time</th>
        <th>Event</th>
        <th>Endpoint</th>
        <th>Response</th>
        <th>Latency</th>
        <th class="col-actions">Actions</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>08:14:10</td>
        <td>user.created</td>
        <td>/webhooks/fcs</td>
        <td><span class="badge badge-2xx">200</span></td>
        <td>182 ms</td>
        <td class="row-actions">
          <button title="View payload">üëÅÔ∏è</button>
          <button title="Redeliver">‚Üª</button>
        </td>
      </tr>
    </tbody>
  </table>
</div>

‚ÄúNew Endpoint‚Äù modal (fields you actually need)

Endpoint URL (POST)

Secret (auto-generate + reveal/rotate)

Signing method: HMAC-SHA256 (header: FCS-Signature)

Events to send: All events / Select events (multi-select)

Retry policy: backoff (e.g., 10s, 30s, 2m, 5m) up to N attempts

Toggle: Pause after N consecutive failures (dead-letter)

Test send: choose sample event (e.g., user.created) and ‚ÄúSend test‚Äù

You can implement as a drawer like we did for Content/Flags.

Minimal JS you‚Äôll want (pseudocode)
// Create endpoint
async function createWebhookEndpoint(data){
  // POST /api/webhooks/endpoints
  // { url, secret, events, signing:'hmac-sha256', retries:{max:5}, pauseAfter:10 }
}

// Send test
async function sendTest(id, type='user.created'){
  // POST /api/webhooks/endpoints/:id/test { type }
}

// Redeliver
async function redeliver(deliveryId){
  // POST /api/webhooks/deliveries/:deliveryId/redeliver
}

// Rotate secret
async function rotateSecret(id){
  // POST /api/webhooks/endpoints/:id/rotate-secret
}

Security & legal guardrails (quick)

Sign every delivery: FCS-Signature: t=<unix>, v1=<hex-hmac>; body must be raw bytes used for HMAC.

Clock skew: receivers should accept only recent timestamps (e.g., ¬±5 min).

Replay protection: include a unique delivery_id; receivers can store and reject duplicates.

PII policy: document which events may include personal data; allow customers to choose minimal vs full payloads.

Audit trail: log creation/rotation/deletion + redelivery actions (who, when, from where).

If you‚Äôd like, I can give you the exact HMAC signature verification snippet for Node/Express (and one for Python/FastAPI) so your receivers can validate FCS-Signature immediately.

You said:
ok
ChatGPT said:

Perfect. Here are ready-to-paste HMAC verification snippets for receiving your webhooks. They all expect your platform to send:

FCS-Signature: t=<unix_seconds>, v1=<hex_hmac_sha256>
FCS-Delivery-Id: <uuid>
Content-Type: application/json


The signature is computed over:
payload_to_sign = "<t>.<raw_request_body_bytes>"

Node (Express)
// npm i express body-parser crypto
import express from "express";
import bodyParser from "body-parser";
import crypto from "crypto";

const app = express();

// IMPORTANT: capture raw body bytes exactly as sent
app.use("/webhooks/fcs", bodyParser.raw({ type: "*/*" })); // or "application/json"

const FCS_SECRET = process.env.FCS_WEBHOOK_SECRET; // e.g., "whsec_ABC123..."

function timingSafeEqual(a, b) {
  const bufA = Buffer.from(a, "utf8");
  const bufB = Buffer.from(b, "utf8");
  if (bufA.length !== bufB.length) return false;
  return crypto.timingSafeEqual(bufA, bufB);
}

app.post("/webhooks/fcs", (req, res) => {
  try {
    const raw = req.body; // Buffer
    const sigHeader = req.header("FCS-Signature") || "";
    const deliveryId = req.header("FCS-Delivery-Id") || "";

    // Parse header: "t=1713812345, v1=abcdef..."
    const parts = Object.fromEntries(
      sigHeader.split(",").map(kv => kv.trim().split("=").map(s => s.trim()))
    );
    const ts = Number(parts.t);
    const v1 = parts.v1;

    if (!ts || !v1) return res.status(400).send("Bad signature header");

    // Reject stale timestamps (>5 min)
    const now = Math.floor(Date.now() / 1000);
    if (Math.abs(now - ts) > 300) return res.status(400).send("Signature expired");

    // Compute HMAC on "<t>.<raw_body>"
    const payloadToSign = Buffer.concat([Buffer.from(String(ts) + "."), raw]);
    const hmac = crypto.createHmac("sha256", FCS_SECRET).update(payloadToSign).digest("hex");

    if (!timingSafeEqual(hmac, v1)) return res.status(400).send("Invalid signature");

    // Prevent replays (store deliveryId for ~24h and reject if seen)
    // await seenBefore(deliveryId) ? 400 : remember(deliveryId)

    // Safe to parse JSON now
    const event = JSON.parse(raw.toString("utf8"));

    // Handle event.type
    switch (event.type) {
      case "user.created":
        // ...
        break;
      case "payment.succeeded":
        // ...
        break;
      default:
        // ignore
    }

    res.status(200).send("ok");
  } catch (e) {
    console.error(e);
    res.status(400).send("Webhook error");
  }
});

app.listen(3000, () => console.log("Listening on :3000"));


Express tip: Do not use express.json() on the webhook route or you‚Äôll lose the exact raw bytes. Use bodyParser.raw() as shown.

Python (FastAPI + Starlette)
# pip install fastapi uvicorn hmac
import hmac, time, hashlib, json
from fastapi import FastAPI, Request, Header, HTTPException

app = FastAPI()
FCS_SECRET = "whsec_ABC123..."  # from your console

def timing_safe_equals(a: str, b: str) -> bool:
    return hmac.compare_digest(a.encode(), b.encode())

@app.post("/webhooks/fcs")
async def fcs_webhook(
    request: Request,
    fcs_signature: str = Header(None, alias="FCS-Signature"),
    delivery_id: str = Header(None, alias="FCS-Delivery-Id")
):
    if not fcs_signature:
        raise HTTPException(400, "Missing signature")

    raw = await request.body()  # bytes

    # Parse header "t=..., v1=..."
    parts = dict(item.strip().split("=") for item in fcs_signature.split(","))
    try:
        ts = int(parts.get("t", "0"))
        v1 = parts.get("v1", "")
    except Exception:
        raise HTTPException(400, "Bad signature header")

    # Timestamp window (¬±5 min)
    if abs(int(time.time()) - ts) > 300:
        raise HTTPException(400, "Signature expired")

    payload = str(ts).encode() + b"." + raw
    digest = hmac.new(FCS_SECRET.encode(), payload, hashlib.sha256).hexdigest()

    if not timing_safe_equals(digest, v1):
        raise HTTPException(400, "Invalid signature")

    # TODO: replay check using delivery_id (cache or DB with TTL)

    event = json.loads(raw.decode("utf-8"))

    # Handle
    if event["type"] == "user.created":
        pass
    elif event["type"] == "payment.succeeded":
        pass

    return {"ok": True}

cURL test (simulate your sender)
SECRET="whsec_ABC123..."
BODY='{"id":"evt_1","type":"user.created","data":{"user_id":"u_123"}}'
TS=$(date +%s)
SIG=$(printf "%s.%s" "$TS" "$BODY" | openssl dgst -sha256 -hmac "$SECRET" -binary | xxd -p -c 256)

curl -i http://localhost:3000/webhooks/fcs \
  -H "Content-Type: application/json" \
  -H "FCS-Delivery-Id: dly_$(uuidgen)" \
  -H "FCS-Signature: t=$TS, v1=$SIG" \
  -d "$BODY"

Receiver checklist (production hardening)

Raw body: verify against raw bytes, then parse JSON.

Timestamp window: reject if outside ¬±5 minutes.

Replay: persist FCS-Delivery-Id with TTL and reject duplicates.

Idempotency: make handlers safe to run twice.

Respond 2xx only after your handler succeeds; use your retry policy for non-2xx.

Least privilege: expose a dedicated URL just for FamilyCircle Secure webhooks.