hanks for the screenshot. “Upload failed → Failed to fetch” means the browser never got a response from S3 (the PUT was blocked before a normal error body could come back). In practice this is caused by one of these, in order of likelihood:

CORS preflight rejection (S3 blocked the OPTIONS/PUT).

Header mismatch (you sign with a Content-Type, but the PUT sends a different one).

Extra forbidden headers (any x-amz-acl, cookies/credentials, etc.).

Wrong endpoint/method (presigned URL is for PUT but client sends POST, etc.).

Below is a short, surgical fix list to make the buttons wire cleanly to the backend and get rid of “Failed to fetch”.

1) Lock the server presign

Make sure your presign includes the same ContentType you’ll send on the PUT and does not add ACL. Example (Node/Express + AWS SDK v3):

// server/src/routes/storage.ts
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";

const s3 = new S3Client({ region: process.env.S3_REGION });

/**
 * Body: { bucket: "familyportal-docs-prod" | "familyportal-photos-prod", key?: string, contentType: string }
 */
export async function presignPut(req, res) {
  const { bucket, contentType, key: providedKey } = req.body;

  if (!bucket || !contentType) {
    return res.status(400).json({ error: "bucket and contentType required" });
  }

  const key = providedKey || `${Date.now()}-${Math.random().toString(36).slice(2)}`;

  // IMPORTANT: include the exact ContentType the client will send
  const command = new PutObjectCommand({
    Bucket: bucket,
    Key: key,
    ContentType: contentType,
    // No ACL here; bucket should be "Bucket owner enforced"
  });

  const uploadUrl = await getSignedUrl(s3, command, { expiresIn: 60 });

  res.json({ uploadUrl, key, bucket, contentType });
}

2) Lock the client upload (the Upload button)

Use fetch, omit credentials, and send only the Content-Type header. No other custom headers.

// client/src/hooks/usePresignedUpload.ts
export async function uploadWithPresign(file: File, bucket: string) {
  // 1) Decide & normalize Content-Type
  const contentType = file.type || "application/octet-stream";

  // 2) Ask server for presigned PUT url
  const presignRes = await fetch("/api/storage/presign", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ bucket, contentType }),
  });
  if (!presignRes.ok) throw new Error("Presign failed");
  const { uploadUrl, key } = await presignRes.json();

  // 3) PUT to S3 using EXACT same Content-Type
  const putRes = await fetch(uploadUrl, {
    method: "PUT",
    mode: "cors",
    credentials: "omit",                  // <-- critical
    headers: { "Content-Type": contentType },
    body: file,
  });

  if (!putRes.ok) {
    // Surface specific S3 error if available
    throw new Error(`S3 PUT failed: ${putRes.status} ${putRes.statusText}`);
  }
  return { key };
}


That’s the function your Upload (n) button should call per selected file.
Select Files only updates local state; Clear empties that state; Mobile Upload uses the same upload function with files from the mobile picker.

3) CORS on BOTH buckets (docs + photos)

What you have is almost perfect. Keep it like this (you can also include "POST" if you ever use presigned POST forms, but it’s not required for PUT):

[
  {
    "AllowedOrigins": ["*"],
    "AllowedMethods": ["GET", "PUT", "HEAD"],
    "AllowedHeaders": ["*"],
    "ExposeHeaders": ["ETag"],
    "MaxAgeSeconds": 3000
  }
]


TIP: Leaving AllowedOrigins: ["*"] is fine for now. Once you’re done testing, restrict it to your app origin (e.g., "https://<your-domain>").

4) Quick local test (proves whether it’s CORS vs. code)

Open DevTools Console on the Upload Center page and paste this (replace with a real presigned URL you just got from /api/storage/presign):

(async () => {
  const url = "<PASTE-PRESIGNED-PUT-URL>";
  const blob = new Blob(["hello"], { type: "application/octet-stream" });
  const res = await fetch(url, {
    method: "PUT",
    mode: "cors",
    credentials: "omit",
    headers: { "Content-Type": "application/octet-stream" },
    body: blob
  });
  console.log(res.status, res.statusText);
})();


If you get 200 OK → S3 CORS is fine; the app code needs to ensure exactly the same header/URL is used.

If it still fails (and Network tab shows the preflight/PUT blocked) → re-check the bucket CORS on both buckets and make sure you saved it.

5) Common “Failed to fetch” causes & the fix we applied

Credentials/cookies sent → we set credentials: "omit".

Mismatched Content-Type → we pass the same ContentType into the presign and the PUT.

Extra headers (e.g., x-amz-acl) → we removed them.

Wrong method → presign returns a PUT URL and client uses PUT.