1) Add the controls to your Upload Center header

Place this inside the card header/actions area of your Upload Center (where your “AI Document Analysis” chip is). It won’t break your current layout—everything is self-contained.

// UploadCenterAIActions.tsx
import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { Select, SelectTrigger, SelectValue, SelectContent, SelectItem } from "@/components/ui/select"
import { Drawer, DrawerContent, DrawerHeader, DrawerTitle, DrawerDescription } from "@/components/ui/drawer"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Sparkles, Loader2, CheckCircle2, AlertTriangle } from "lucide-react"

type Mode = "auto" | "id" | "forms"

export type AIResult = {
  mode: Mode
  documentType: string
  fields: { key: string; value: string; confidence: number; pii?: boolean }[]
  meta?: { api_used?: string; elapsed_ms?: number }
  warning?: string
}

export function UploadCenterAIActions({
  file,                                     // File | null (selected upload)
  onApply,                                  // (fields) => void   // push into your form
}: {
  file: File | null
  onApply: (fields: AIResult["fields"]) => void
}) {
  const [mode, setMode] = useState<Mode>("auto")
  const [open, setOpen] = useState(false)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [result, setResult] = useState<AIResult | null>(null)

  async function runAnalysis() {
    if (!file) return
    setLoading(true)
    setError(null)
    setResult(null)
    try {
      // POST to your backend; see #2 below
      const body = new FormData()
      body.append("file", file)
      body.append("mode", mode)

      const res = await fetch("/api/inbox/analyze", { method: "POST", body })
      if (!res.ok) throw new Error(`HTTP ${res.status}`)
      const json = await res.json() as { ok: boolean; result?: AIResult; error?: string }
      if (!json.ok || !json.result) throw new Error(json.error || "Unknown analysis error")
      setResult(json.result)
      setOpen(true)
    } catch (e: any) {
      setError(e.message || "Failed to analyze document")
    } finally {
      setLoading(false)
    }
  }

  const Status = () => {
    if (loading) return (
      <Badge variant="secondary" className="gap-1"><Loader2 className="h-3 w-3 animate-spin"/>Processing</Badge>
    )
    if (error) return (
      <Badge variant="destructive" className="gap-1"><AlertTriangle className="h-3 w-3"/>Error</Badge>
    )
    if (result) return (
      <Badge variant="outline" className="gap-1 text-green-700 border-green-300">
        <CheckCircle2 className="h-3 w-3"/>Ready
      </Badge>
    )
    return null
  }

  return (
    <div className="flex items-center gap-2">
      <Select value={mode} onValueChange={(v: Mode) => setMode(v)}>
        <SelectTrigger className="w-[160px]">
          <SelectValue placeholder="Mode" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="auto">Auto (Hybrid)</SelectItem>
          <SelectItem value="id">ID (AnalyzeID)</SelectItem>
          <SelectItem value="forms">Forms (Queries)</SelectItem>
        </SelectContent>
      </Select>

      <Button onClick={runAnalysis} disabled={!file || loading} className="gap-2">
        <Sparkles className="h-4 w-4" />
        Analyze with AI
      </Button>

      <Status />

      {/* Results drawer */}
      <Drawer open={open} onOpenChange={setOpen}>
        <DrawerContent className="max-h-[80vh]">
          <DrawerHeader>
            <DrawerTitle>AI Analysis</DrawerTitle>
            <DrawerDescription>
              {result?.meta?.api_used ? `Using ${result.meta.api_used}` : "Structured extraction"}
              {result?.warning ? ` • ${result.warning}` : ""}
            </DrawerDescription>
          </DrawerHeader>

          <div className="px-6 pb-6">
            {result && (
              <div className="space-y-3">
                <div className="text-sm text-muted-foreground">
                  Mode: <span className="font-medium">{result.mode}</span> • Type: <span className="font-medium">{result.documentType}</span>
                </div>

                <ScrollArea className="h-[48vh] rounded border p-3 bg-background">
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                    {result.fields.map((f, i) => (
                      <div key={i} className="rounded border p-3">
                        <div className="flex items-center justify-between mb-1">
                          <span className="text-xs font-medium text-muted-foreground">
                            {f.key.replace(/_/g," ").toLowerCase().replace(/\b\w/g, c=>c.toUpperCase())}
                          </span>
                          <Badge variant="outline">
                            {Math.round(f.confidence)}%
                          </Badge>
                        </div>
                        <div className="text-sm font-mono break-words">{f.value || "—"}</div>
                      </div>
                    ))}
                  </div>
                </ScrollArea>

                <div className="flex justify-end gap-2">
                  <Button variant="outline" onClick={() => setOpen(false)}>Close</Button>
                  <Button onClick={() => { onApply(result.fields); setOpen(false) }}>
                    Apply to form
                  </Button>
                </div>
              </div>
            )}
          </div>
        </DrawerContent>
      </Drawer>
    </div>
  )
}


Where to mount it: inside your Upload Center card header—e.g.:

// inside <CardHeader> right actions area
<UploadCenterAIActions
  file={selectedFile}                           // your current file state
  onApply={(fields) => {
    // map to your form (title/category/description or custom fields)
    // example: setDescription from issuer + doc type, etc.
  }}
/>

2) Minimal backend handler (hybrid ready)

Point the button to /api/inbox/analyze. If you already have this route, just adapt the shape. This stub matches the “hybrid” plan we discussed.

// server/routes/api-inbox-analyze.ts (or similar)
import type { Request, Response } from "express"
import { analyzeHybrid, analyzeID, analyzeSSN, analyzeInsurance, analyzeGeneric } from "../lib/analyzers" // your implementations

export async function postAnalyze(req: Request, res: Response) {
  try {
    const mode = (req.body.mode || "auto") as "auto"|"id"|"forms"
    const file = (req as any).files?.file || req.file  // multer/busboy
    if (!file) return res.status(400).json({ ok:false, error:"Missing file" })
    const bytes: Uint8Array = file.buffer ?? new Uint8Array(await file.arrayBuffer?.())

    let result
    if (mode === "id") {
      result = await analyzeID(bytes)
      result.mode = "id"
    } else if (mode === "forms") {
      // add light heuristic here if you want SSN vs insurance
      result = await analyzeGeneric(bytes)
      result.mode = "forms"
    } else {
      result = await analyzeHybrid(bytes)   // the hybrid from my prior message
      result.mode = "auto"
    }

    return res.json({ ok:true, result })
  } catch (e: any) {
    return res.status(500).json({ ok:false, error: e.message || "Analyze error" })
  }
}


You already have working Textract + Vision code. Plug your real functions into the imports (analyzeHybrid, analyzeID, etc.). If you need the runVisionFusion merge helper, say the word and I’ll paste it.

3) Missing icon / polish (what you asked to “lmk”)

Icon: Use Sparkles (AI action) and CheckCircle2 / AlertTriangle / Loader2 for status. Those are already included above.

Sidebar: If you want a quick entry in your left nav, add Sparkles next to “AI Suggestions” linking to the page/section.

Quick badge: The status pill next to the button is tiny but super clear.

Keyboard affordance: Button is disabled until a file is selected.

4) Optional: auto-apply common suggestions

When users click Apply to form, map a few common keys:

// example inside onApply(fields)
const map = Object.fromEntries(fields.map(f => [f.key.toLowerCase(), f.value]))

setFormState(prev => ({
  ...prev,
  title: prev.title || map.document_number ? `ID ${map.document_number}` :
         prev.title || map.memberid ? `Insurance ${map.memberid}` :
         prev.title || "Document",
  category: prev.category || (map.ssn ? "identity_documents" :
                              map.memberid ? "insurance" : "general"),
  description: prev.description || (map.issuer ? `Issuer: ${map.issuer}` : "")
}))
