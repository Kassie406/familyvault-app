2) Replit Secrets

Open Tools → Secrets and add:

LAMBDA_URL → your API Gateway base URL (no trailing slash), e.g.
https://abc123.execute-api.us-east-1.amazonaws.com/prod

You asked to keep SSNs unmasked — the Lambda below does that by default.

3) Run
npm install
npm run dev


Replit will show two processes (Vite and API). Open the web preview.
When you’re ready to serve a single production server:

npm run build
npm start

4) Backend (AWS Lambda) you can paste as-is

If you still need the Lambda, use this (matches the UI & supports mode: auto|id|forms|tables):

# lambda_function.py
import json, base64, boto3, re

tex = boto3.client("textract")

def _ok(body: dict, code=200):
    return {
        "statusCode": code,
        "headers": {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Headers": "Content-Type",
            "Access-Control-Allow-Methods": "OPTIONS,POST"
        },
        "body": json.dumps(body)
    }

def _err(msg: str, code=500):
    return _ok({"error": msg}, code)

def _map_id_field(ft: str) -> str:
    m = {
        "FIRST_NAME":"First Name","MIDDLE_NAME":"Middle Name","LAST_NAME":"Last Name",
        "DOCUMENT_NUMBER":"Document Number","DATE_OF_BIRTH":"Date of Birth",
        "EXPIRATION_DATE":"Expiration Date","DATE_OF_ISSUE":"Issue Date",
        "ADDRESS":"Address","CITY_IN_ADDRESS":"City","STATE_IN_ADDRESS":"State",
        "ZIP_CODE_IN_ADDRESS":"ZIP Code","CLASS":"License Class","ENDORSEMENTS":"Endorsements",
        "RESTRICTIONS":"Restrictions","ID_TYPE":"Document Type"
    }
    return m.get(ft, ft.replace("_"," ").title())

def parse_analyze_id(resp):
    out = {}
    for doc in resp.get("IdentityDocuments", []):
        for f in doc.get("IdentityDocumentFields", []):
            ftype = (f.get("Type") or {}).get("Text") or ""
            val = (f.get("ValueDetection") or {}).get("Text") or ""
            conf = (f.get("ValueDetection") or {}).get("Confidence") or 0
            if not ftype or not val or conf < 80: 
                continue
            name = _map_id_field(ftype)
            # join name parts if needed
            if ftype in ("FIRST_NAME","MIDDLE_NAME","LAST_NAME"):
                prev = out.get("Person Name", "")
                out["Person Name"] = (prev + " " + val).strip()
            else:
                out[name] = val
    return out

def parse_forms(resp):
    blocks = {b["Id"]: b for b in resp.get("Blocks", [])}
    keys = [b for b in resp.get("Blocks", []) if b["BlockType"]=="KEY_VALUE_SET" and "KEY" in b.get("EntityTypes",[])]
    vals = {b["Id"]: b for b in resp.get("Blocks", []) if b["BlockType"]=="KEY_VALUE_SET" and "VALUE" in b.get("EntityTypes",[])}
    def get_text(block):
        txt=[]
        for rel in block.get("Relationships",[]):
            if rel["Type"]=="CHILD":
                for cid in rel["Ids"]:
                    w=blocks[cid]
                    if w["BlockType"]=="WORD":
                        txt.append(w["Text"])
        return " ".join(txt).strip()
    def find_val(k):
        for rel in k.get("Relationships",[]):
            if rel["Type"]=="VALUE":
                for vid in rel["Ids"]:
                    if vid in vals: return vals[vid]
        return None
    out={}
    for k in keys:
        v = find_val(k)
        if not v: continue
        ktxt, vtxt = get_text(k), get_text(v)
        if not ktxt or not vtxt: continue
        field = ktxt.strip().rstrip(":*").strip().lower()
        mapping = {
            "name":"Person Name","full name":"Person Name","patient name":"Person Name","member name":"Person Name",
            "ssn":"Social Security Number","social security":"Social Security Number",
            "policy number":"Policy Number","member id":"Member ID","group number":"Group Number",
            "date of birth":"Date of Birth","dob":"Date of Birth","address":"Address","effective date":"Effective Date"
        }
        pretty = next((mapping[m] for m in mapping if m in field), None) or ktxt.title()
        out[pretty] = vtxt
    return out

def guess_type(fields: dict, filename: str) -> str:
    fn = (filename or "").lower()
    if "social security" in fn or "Social Security Number" in fields: return "Social Security Card"
    if "license" in fn or "License Class" in fields: return "Driver License"
    if "passport" in fn: return "Passport"
    if "insurance" in fn or "Policy Number" in fields: return "Insurance Card"
    return "Document"

def lambda_handler(event, _ctx):
    try:
        body = event.get("body")
        if isinstance(body, str):
            body = json.loads(body)
        elif body is None:
            body = event

        filename = body.get("filename","document")
        mode = (body.get("mode") or "auto").lower()
        file_b64 = body["fileContent"]
        file_bytes = base64.b64decode(file_b64)

        # choose analysis path
        if mode=="id":
            resp = tex.analyze_id(DocumentPages=[{"Bytes": file_bytes}])
            fields = parse_analyze_id(resp)
            used = "Textract AnalyzeID"
        elif mode=="forms":
            resp = tex.analyze_document(Document={"Bytes": file_bytes}, FeatureTypes=["FORMS"])
            fields = parse_forms(resp)
            used = "Textract AnalyzeDocument(FORMS)"
        elif mode=="tables":
            resp = tex.analyze_document(Document={"Bytes": file_bytes}, FeatureTypes=["TABLES"])
            fields = parse_forms(resp)  # reuse parsing; you can extend for table cells
            used = "Textract AnalyzeDocument(TABLES)"
        else:
            # auto: try AnalyzeID first; fallback to FORMS
            try:
                resp = tex.analyze_id(DocumentPages=[{"Bytes": file_bytes}])
                fields = parse_analyze_id(resp)
                used = "Textract AnalyzeID"
                if not fields:
                    raise Exception("Empty AnalyzeID")
            except:
                resp = tex.analyze_document(Document={"Bytes": file_bytes}, FeatureTypes=["FORMS"])
                fields = parse_forms(resp)
                used = "Textract AnalyzeDocument(FORMS)"

        doc_type = guess_type(fields, filename)
        person = fields.get("Person Name","")
        suggested = f"{doc_type} {person}".strip()

        # NO SSN MASKING as requested
        result = {
            "extractedFields": fields,
            "suggestedFilename": suggested or filename,
            "suggestedDestinations": (
                [{"name": person, "category": "Family Member"}] if person else []
            ) + [{"name": "Laura Reynolds", "category": "Family Member"}],
            "detailsCount": len(fields),
            "confidence": "high" if fields else "low",
            "engine": used
        }
        return _ok(result)

    except Exception as e:
        print("ERR:", e)
        return _err("Internal server error")


API Gateway route: POST /api/inbox/analyze to the Lambda.
Make sure CORS is enabled.

5) Quick sanity test (curl)
# Base64 a sample file (mac/linux)
b64=$(base64 -w0 sample-id.jpg)
curl -X POST "$LAMBDA_URL/api/inbox/analyze" \
  -H 'Content-Type: application/json' \
  -d '{"filename":"sample-id.jpg","fileContent":"'"$b64"'","mode":"id"}'


You should see extractedFields, suggestedFilename, detailsCount, etc.